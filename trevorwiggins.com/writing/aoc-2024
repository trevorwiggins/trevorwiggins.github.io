<!DOCTYPE html><html lang="en" class="scroll-smooth"> 
<!-- Mirrored from kyle.so/writing/aoc-2024 by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 04 Feb 2026 14:30:17 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><!-- start analytics --><script defer data-domain="kyle.so" src="../../a.kyle.so/js/script.outbound-links.js"></script><!-- end analytics --><link rel="stylesheet" href="../../cdn.jsdelivr.net/npm/katex%400.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous"><script defer src="../../cdn.jsdelivr.net/npm/katex%400.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script><script defer src="../../cdn.jsdelivr.net/npm/katex%400.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script><!-- start meta --><meta charset="UTF-8"><meta name="description" content="A log of my experience with Advent of Code 2024, there are spoilers in here so beware."><meta name="viewport" content="width=device-width"><link rel="icon" type="image/x-icon" href="../favicon.svg"><meta name="generator" content="Astro v5.14.5"><meta name="robots" content="index, follow"><meta name="keywords" content="kyle dickey, kyle, dickey, dickeyy, imdickey, software engineer, junior software engineer, engineer, freelancer, developer, colorado, colorado state university, diary, tip.dev, quack, quack discord bot, alias, wordle, wordle clone, computer science, computer science major, cs major, cs, web development, web dev, web, front end, front-end, back end, back-end, javascript, typescript, react, reactjs, node, node.js, nodejs, npm, discord bot, discord bots, discord bot creator, discord bot creators, discord bots, discord bot developer, discord bot developers, discord bot creator, discord bot creators, discord bots, discord bot developer, advent of code 2024, advent of code solutions 2024, aoc 2024 solutions, advent of code 2024 answers, advent of code 2024 day 1 solution, advent of code 2024 day 2 solution, advent of code 2024 day 3 solution, advent of code 2024 day 4 solution, advent of code 2024 day 5 solution, advent of code 2024 day 6 solution, advent of code 2024 day 7 solution, advent of code 2024 day 8 solution, advent of code 2024 day 9 solution, advent of code 2024 day 10 solution, advent of code 2024 day 11 solution, advent of code 2024 day 12 solution, advent of code 2024 day 13 solution, advent of code 2024 day 14 solution, advent of code 2024 day 15 solution, advent of code 2024 day 16 solution, advent of code 2024 day 17 solution, advent of code 2024 day 18 solution, advent of code 2024 day 19 solution, advent of code 2024 day 20 solution, advent of code 2024 day 21 solution, advent of code 2024 day 22 solution, advent of code 2024 day 23 solution, advent of code 2024 day 24 solution, advent of code 2024 day 25 solution, aoc 2024 golang solutions, advent of code go, advent of code 2024 explained, advent of code 2024 go, advent of code 2024 walkthrough, how to solve advent of code 2024, programming puzzles, coding challenges 2024, go programming exercises, daily coding problems, algorithmic puzzles, historian hysteria, red-nosed reports, mull it over, ceres search, print queue, guard gallivant, bridge repair, resonant collinearity, disk fragmenter, hoof it, plutonian pebbles, garden groups, claw contraption, restroom redoubt, warehouse woes, reindeer maze, chronospatial computer, ram run, linen layout, race condition, keypad conundrum, monkey market, lan party, crossed wires, code chronicle, go optimization, algorithm complexity, advent of code 2024 tips, aoc 2024 hints"><!-- end meta --><!-- start open graph --><meta property="og:type" content="website"><meta property="og:title" content="Advent of Code 2024 - Kyle Dickey"><meta property="og:description" content="A log of my experience with Advent of Code 2024, there are spoilers in here so beware."><meta property="og:image" content="/blog-og-images/aoc-2024.png"><meta property="og:url" content="http://localhost:4321/writing/aoc-2024/"><!-- end open graph --><!-- start twitter --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kyledickeyy"><meta name="twitter:creator" content="@kyledickeyy"><meta name="twitter:title" content="Advent of Code 2024 - Kyle Dickey"><meta name="twitter:description" content="A log of my experience with Advent of Code 2024, there are spoilers in here so beware."><meta name="twitter:image" content="/blog-og-images/aoc-2024.png"><!-- end twitter --><title>Advent of Code 2024</title><link rel="stylesheet" href="../_astro/cv.CGBryDnQ.css">
<link rel="stylesheet" href="../_astro/_slug_.Bih3wAnU.css"></head> <body class="m-0
            flex
            min-h-screen
            flex-col
            p-0
            w-full
            items-center
            justify-center"> <main class="flex flex-grow items-center justify-center w-full"> <nav class="absolute top-[1rem] left-[1rem] sm:left-[14rem] sm:top-[4rem] w-32"> <div class="space-y-2 text-sm text-foreground/60"> <a href="../writing.html" class="hover:text-foreground flex flex-row items-center gap-2 transition-all ease-in-out"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-3 mb-1"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg> <span class="font-serif italic">Writing</span> </a> </div> </nav> <div class="flex-1 flex justify-center min-h-screen"> <div class="w-full sm:w-[100%] md:w-[75%] lg:w-[55%] px-4 sm:px-8 py-8"> <div class="flex items-start justify-between w-full mt-8"> <div class="flex flex-col item-start justify-center"> <h1 class="font-serif italic text-2xl">Advent of Code 2024</h1> <p class="text-foreground/60 font-light"> A log of my experience with Advent of Code 2024, there are spoilers in here so beware. </p> <p class="text-foreground/60 font-light text-sm italic font-serif mt-4"> <date> December 25, 2024 </date> by <author>Kyle Dickey</author> </p> </div> </div>  <article class="prose-blog"> <br/>
<div class="my-4 p-3 rounded-[5px] border-l-4 border-white bg-[#1f1f1f]">  <div class="prose dark:prose-invert max-w-none prose-p:text-foreground/80 prose-p:font-normal"> <p>All of my Advent of Code solutions are available on
<a href="https://github.com/dickeyy/adventofcode/tree/main/2024">GitHub</a>.</p> </div> </div>
<h2 id="day-25-code-chronicle">Day 25: Code Chronicle</h2>
<p>Merry Christmas!! Today is the final day of Advent of Code 2024!</p>
<p>Today’s puzzle, appropriately being Christmas Day, was about analyzing lock and key combinations in
a fancy virtual five-pin tumbler system. We were given schematics for various locks and keys, and
needed to determine which ones could work together based on their pin heights.</p>
<p>The schematics used a simple ASCII format where ’#’ represented filled space and ’.’ represented
empty space. The key insight was that locks had their top row filled and bottom row empty, while
keys had the opposite pattern. Each schematic could be converted into a sequence of heights by
counting the number of filled spaces in each column.</p>
<p>I started by creating a function to parse the heights from the schematic format:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> parsePattern(lines []</span><span style="color:#F97583">string</span><span style="color:#B392F0">) []</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    heights </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">5</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> row </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> lines {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> col </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> lines[row] {</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> lines[row][col] </span><span style="color:#F97583">==</span><span style="color:#FFAB70"> &#39;#&#39;</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">                heights[col]</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#6B737C">    // Adjust for the fixed top/bottom row</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> heights {</span></span>
<span class="line"><span style="color:#B392F0">        heights[i]</span><span style="color:#F97583">--</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> heights</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core logic involved checking if a lock and key could fit together. This meant ensuring that for
each column, the combined height of the lock’s pin and the key’s pin didn’t exceed the available
space:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> canFit(lock, key []</span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> lock {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> lock[i] </span><span style="color:#F97583">+</span><span style="color:#B392F0"> key[i] </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 5</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 1 simply required counting all valid lock/key combinations. Since this was the final day of
Advent of Code 2024, there was no Part 2 - just a heartwarming conclusion to the story about helping
the Chief Historian complete Santa’s chronicle in time for the sleigh launch.</p>
<h3 id="thoughts">Thoughts</h3>
<p>Today’s puzzle was a nice Christmas present - interesting enough to be engaging but not so complex
that it would take away from holiday celebrations. The visualization of the pins and keys using
ASCII art made it particularly fun to work with, and the physical analogy to tumbler locks helped
make the problem intuitive.</p>
<p>The most elegant aspect was how the puzzle took something as complex as a real pin tumbler lock and
abstracted it into a simple height-matching problem. The fact that we only needed to track column
heights rather than the full lock/key geometry made the solution clean and straightforward.</p>
<p>I’d rate this a 4/10 difficulty - while it required careful attention to detail in parsing the
schematics and checking compatibility, the core logic was relatively straightforward. The lack of a
Part 2 was a nice touch, letting us wrap up the Advent of Code journey on a satisfying note.</p>
<p><em>Merry Christmas, and see you next year!</em></p>
<hr/>
<h2 id="day-24-crossed-wires">Day 24: Crossed Wires</h2>
<p>Today’s puzzle placed us in a simulation of boolean logic gates and wires. We were given a network
of AND, OR, and XOR gates, with initial wire values that propagate through the system. The twist was
that some gates had their output wires accidentally swapped, and we needed to figure out which ones.</p>
<p>For Part 1, we needed to calculate the final values on all z-wires after evaluating the circuit. I
approached this using a map to track wire values and gates:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> GateInfo </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    operation </span><span style="color:#F97583">int</span><span style="color:#6B737C"> // 0=AND, 1=OR, 2=XOR</span></span>
<span class="line"><span style="color:#B392F0">    inputs    []</span><span style="color:#F97583">string</span></span>
<span class="line"><span style="color:#B392F0">    output    </span><span style="color:#F97583">string</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core logic involved evaluating gates as soon as their input values became available:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> len(gates) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> wireName, gate </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> gates {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> canEvalGate(gate, wires) {</span></span>
<span class="line"><span style="color:#B392F0">            wires[wireName] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> evaluateGate(gate, wires)</span></span>
<span class="line"><span style="color:#B392F0">            delete(gates, wireName)</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 revealed that this circuit was actually meant to be a binary adder, adding numbers
represented by x-wires and y-wires to produce a result on the z-wires. However, four pairs of gate
outputs were swapped. The key insight was recognizing the structure of a binary adder - it’s built
from a series of half-adders and full-adders that process bits from least to most significant.</p>
<p>To find the swapped wires, I looked for gates that didn’t match the expected adder pattern:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#6B737C">// Find half adder gates for each bit position</span></span>
<span class="line"><span style="color:#B392F0">m1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> find(fmt.Sprintf(</span><span style="color:#FFAB70">&quot;x</span><span style="color:#F8F8F8">%s</span><span style="color:#FFAB70">&quot;</span><span style="color:#B392F0">, n), fmt.Sprintf(</span><span style="color:#FFAB70">&quot;y</span><span style="color:#F8F8F8">%s</span><span style="color:#FFAB70">&quot;</span><span style="color:#B392F0">, n), </span><span style="color:#FFAB70">&quot;XOR&quot;</span><span style="color:#B392F0">, gateStrings)</span></span>
<span class="line"><span style="color:#B392F0">n1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> find(fmt.Sprintf(</span><span style="color:#FFAB70">&quot;x</span><span style="color:#F8F8F8">%s</span><span style="color:#FFAB70">&quot;</span><span style="color:#B392F0">, n), fmt.Sprintf(</span><span style="color:#FFAB70">&quot;y</span><span style="color:#F8F8F8">%s</span><span style="color:#FFAB70">&quot;</span><span style="color:#B392F0">, n), </span><span style="color:#FFAB70">&quot;AND&quot;</span><span style="color:#B392F0">, gateStrings)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#B392F0"> carry </span><span style="color:#F97583">!=</span><span style="color:#FFAB70"> &quot;&quot;</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">    // Full adder logic when we have a carry bit</span></span>
<span class="line"><span style="color:#B392F0">    r1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> find(carry, m1, </span><span style="color:#FFAB70">&quot;AND&quot;</span><span style="color:#B392F0">, gateStrings)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> r1 </span><span style="color:#F97583">==</span><span style="color:#FFAB70"> &quot;&quot;</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        m1, n1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> n1, m1</span></span>
<span class="line"><span style="color:#B392F0">        swapped </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(swapped, m1, n1)</span></span>
<span class="line"><span style="color:#B392F0">        r1 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> find(carry, m1, </span><span style="color:#FFAB70">&quot;AND&quot;</span><span style="color:#B392F0">, gateStrings)</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-1">Thoughts</h3>
<p>Today’s puzzle was a fascinating combination of digital logic and pattern recognition. While Part 1
was straightforward circuit simulation, Part 2’s realization that we were working with a binary
adder added an interesting layer of complexity. The key to solving Part 2 was understanding how
binary adders are constructed - they follow a very specific pattern of XOR and AND gates to handle
each bit position and carry values.</p>
<p>The most elegant aspect was how the puzzle guided us from simple gate evaluation to discovering the
underlying structure of a binary adder. Once you recognized the pattern of half-adders and
full-adders, finding the swapped wires became much more manageable - they were the ones that broke
this expected pattern.</p>
<p>I’d rate this a 6/10 difficulty. The circuit simulation itself wasn’t particularly complex, but
recognizing and properly handling the binary adder structure in Part 2 required some careful
thinking and debugging.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-23-lan-party">Day 23: LAN Party</h2>
<p>Today’s puzzle placed us in a network mapping scenario at Easter Bunny HQ, trying to analyze
computer connections to locate a LAN party. We were given a list of computer connections in the
format <code>kh-tc</code> (representing bidirectional connections between computers), and needed to analyze
different types of connected groups.</p>
<p>For Part 1, we needed to find sets of three interconnected computers where at least one computer
name started with ‘t’. I started by creating an adjacency list representation of the network:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> parseInput(input </span><span style="color:#F97583">string</span><span style="color:#B392F0">) AdjList {</span></span>
<span class="line"><span style="color:#B392F0">    adj </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(AdjList)</span></span>
<span class="line"><span style="color:#B392F0">    lines </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strings.Split(input, </span><span style="color:#FFAB70">&quot;\n&quot;</span><span style="color:#B392F0">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> _, line </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> lines {</span></span>
<span class="line"><span style="color:#B392F0">        nodes </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strings.Split(line, </span><span style="color:#FFAB70">&quot;-&quot;</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        a, b </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> nodes[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">], nodes[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // Initialize maps if needed</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> adj[a] </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> nil</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            adj[a] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">string</span><span style="color:#B392F0">]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> adj[b] </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> nil</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            adj[b] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">string</span><span style="color:#B392F0">]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // Add bidirectional edge</span></span>
<span class="line"><span style="color:#B392F0">        adj[a][b] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">        adj[b][a] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> adj</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core of Part 1 involved finding triangles (sets of three interconnected nodes) in the graph. The
trick was to avoid counting each triangle multiple times since we could find the same triangle
starting from any of its three nodes:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#6B737C">// Inside findTriangles function</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> node </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> adj {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> neighbor </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> adj[node] {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> seen[neighbor</span><span style="color:#F97583">+</span><span style="color:#B392F0">node] {</span></span>
<span class="line"><span style="color:#F97583">            continue</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">        seen[node</span><span style="color:#F97583">+</span><span style="color:#B392F0">neighbor] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // Check each neighbor of neighbor for triangles</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> non </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> adj[neighbor] {</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> non </span><span style="color:#F97583">==</span><span style="color:#B392F0"> node {</span></span>
<span class="line"><span style="color:#F97583">                continue</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> adj[non][node] </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> hasTPrefixNode(node, neighbor, non) {</span></span>
<span class="line"><span style="color:#B392F0">                count</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"><span style="color:#F97583">return</span><span style="color:#B392F0"> count </span><span style="color:#F97583">/</span><span style="color:#F8F8F8"> 3</span><span style="color:#6B737C">  // Each triangle is counted 3 times</span></span></code></pre>
<p>Part 2 changed the game completely - we needed to find the largest set of computers where every
computer was directly connected to every other computer (in graph theory, this is known as a maximum
clique). This required implementing the Bron-Kerbosch algorithm, which efficiently finds maximal
cliques in a graph.</p>
<h3 id="thoughts-2">Thoughts</h3>
<p>Today’s puzzle was a fascinating exploration of graph theory concepts. The transition from finding
triangles in Part 1 to finding the maximum clique in Part 2 was particularly elegant. While my first
attempt at Part 2 tried to brute force the solution by checking all possible combinations, that
quickly proved impractical. The key insight was recognizing this as a classic maximum clique problem
and implementing the Bron-Kerbosch algorithm.</p>
<p>The trickiest part was getting the triangle detection correct in Part 1 - it’s easy to either miss
triangles or count them multiple times if you’re not careful with how you track seen combinations.
The use of a <code>seen</code> map to prevent double-counting while still finding all valid triangles took some
careful thinking to get right.</p>
<p>I’d rate this a 5/10 difficulty - while the concepts aren’t overly complex, implementing everything
correctly, especially the Bron-Kerbosch algorithm for Part 2, required solid understanding of graph
algorithms and careful attention to detail.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-22-monkey-market">Day 22: Monkey Market</h2>
<p>Today’s puzzle placed us in a jungle marketplace, trying to predict pseudorandom number sequences
used by monkeys to set prices for hiding spots. The challenge involved implementing a specific
sequence generator and then analyzing patterns in the resulting numbers.</p>
<p>For Part 1, we needed to generate 2000 numbers for each starting value using a specific mixing and
pruning process. The sequence generation was straightforward once you understood the steps:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> getSecretNum(num </span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    num </span><span style="color:#F97583">=</span><span style="color:#B392F0"> prune(mix(num</span><span style="color:#F97583">*</span><span style="color:#F8F8F8">64</span><span style="color:#B392F0">, num))   </span><span style="color:#6B737C">// Step 1</span></span>
<span class="line"><span style="color:#B392F0">    num </span><span style="color:#F97583">=</span><span style="color:#B392F0"> prune(mix(num</span><span style="color:#F97583">/</span><span style="color:#F8F8F8">32</span><span style="color:#B392F0">, num))   </span><span style="color:#6B737C">// Step 2</span></span>
<span class="line"><span style="color:#B392F0">    num </span><span style="color:#F97583">=</span><span style="color:#B392F0"> prune(mix(num</span><span style="color:#F97583">*</span><span style="color:#F8F8F8">2048</span><span style="color:#B392F0">, num)) </span><span style="color:#6B737C">// Step 3</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> num</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> mix(a, b </span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> { </span><span style="color:#F97583">return</span><span style="color:#B392F0"> a </span><span style="color:#F97583">^</span><span style="color:#B392F0"> b }</span></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> prune(a </span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0">  { </span><span style="color:#F97583">return</span><span style="color:#B392F0"> a </span><span style="color:#F97583">%</span><span style="color:#B392F0"> PRUNE_NUM }</span></span></code></pre>
<p>Part 2 added an interesting twist - instead of looking at the full numbers, we only cared about
their ones digits and needed to find sequences of changes that would maximize our banana collection.
This required tracking a sliding window of differences between consecutive digits:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#B392F0">last4 </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> [</span><span style="color:#F8F8F8">4</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">{</span><span style="color:#F8F8F8">10</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">10</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">10</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">10</span><span style="color:#B392F0">} </span><span style="color:#6B737C">// start with impossible changes</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#F8F8F8"> 2000</span><span style="color:#B392F0">; i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    prev </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> num </span><span style="color:#F97583">%</span><span style="color:#F8F8F8"> 10</span></span>
<span class="line"><span style="color:#B392F0">    num </span><span style="color:#F97583">=</span><span style="color:#B392F0"> getSecretNum(num)</span></span>
<span class="line"><span style="color:#B392F0">    curr </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> num </span><span style="color:#F97583">%</span><span style="color:#F8F8F8"> 10</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // shift the window and add new change</span></span>
<span class="line"><span style="color:#B392F0">    last4[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> last4[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">    last4[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> last4[</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">    last4[</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> last4[</span><span style="color:#F8F8F8">3</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">    last4[</span><span style="color:#F8F8F8">3</span><span style="color:#B392F0">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> curr </span><span style="color:#F97583">-</span><span style="color:#B392F0"> prev</span></span>
<span class="line"><span style="color:#F97583">    ...</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The key insight was using maps to efficiently track both the sequences we’ve seen (seen) and their
cumulative values (sequences). This let us avoid counting the same sequence multiple times for a
given starting number while still accumulating the total bananas we could collect.</p>
<h3 id="thoughts-3">Thoughts</h3>
<p>Today’s puzzle was an interesting mix of number theory and pattern recognition. While implementing
the sequence generator itself was straightforward, the real elegance came in Part 2’s approach to
finding optimal price change sequences.</p>
<p>The solution ended up being much simpler than my first attempts, which tried to brute force all
possible four-number sequences. Instead, by tracking the sequences we actually encounter and their
resulting values, we let the problem’s natural constraints guide us to the answer.</p>
<p>I particularly enjoyed how the puzzle led us from thinking about full numbers in Part 1 to just
their ones digits and changes in Part 2. It’s a nice reminder that sometimes you don’t need all the
information - just the relevant bits.</p>
<p>I’d rate this a 3/10 difficulty. Once you understand what the puzzle is asking for, both parts
follow naturally from each other and don’t require any particularly complex algorithms or data
structures.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-21-keypad-conundrum">Day 21: Keypad Conundrum</h2>
<p>Today’s puzzle dropped us into a fascinating chain of robot control systems, where we had to help
guide robots through a sequence of keypads to type door codes. What made this particularly
interesting was the layered nature of control - we’re controlling a robot that controls another
robot that controls another robot, and so on, all the way down to the final robot typing on a
numeric keypad!</p>
<p>The puzzle involved two types of keypads: a numeric keypad (like an ATM) and a directional keypad
(with arrows and an activate button). Each robot arm starts pointing at the ‘A’ button on its
keypad, and we had to find the shortest possible sequence of button presses that would ultimately
type codes like “029A” on the door’s numeric keypad.</p>
<p>For Part 1, I started by representing each keypad as a set of coordinates to track possible
movements:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#B392F0">numMap </span><span style="color:#F97583">:=</span><span style="color:#F97583"> map</span><span style="color:#B392F0">[</span><span style="color:#F97583">string</span><span style="color:#B392F0">]Coord{</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;A&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;0&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;1&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;2&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;3&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#6B737C">    // ... and so on</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">dirMap </span><span style="color:#F97583">:=</span><span style="color:#F97583"> map</span><span style="color:#B392F0">[</span><span style="color:#F97583">string</span><span style="color:#B392F0">]Coord{</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;A&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;^&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;&lt;&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;v&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#FFAB70">    &quot;&gt;&quot;</span><span style="color:#B392F0">: {</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">},</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core challenge was handling the sequences of movements. Each step needed to translate into a
series of directional presses to move the robot arm to the target button:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> getNumPadSequence(input []</span><span style="color:#F97583">string</span><span style="color:#B392F0">, start </span><span style="color:#F97583">string</span><span style="color:#B392F0">, numMap </span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">string</span><span style="color:#B392F0">]Coord) []</span><span style="color:#F97583">string</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    curr </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> numMap[start]</span></span>
<span class="line"><span style="color:#B392F0">    seq </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> []</span><span style="color:#F97583">string</span><span style="color:#B392F0">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> _, char </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> input {</span></span>
<span class="line"><span style="color:#B392F0">        dest </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> numMap[char]</span></span>
<span class="line"><span style="color:#B392F0">        dx, dy </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> dest.x</span><span style="color:#F97583">-</span><span style="color:#B392F0">curr.x, dest.y</span><span style="color:#F97583">-</span><span style="color:#B392F0">curr.y</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // Build movement sequences based on relative positions</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> curr.y </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 0</span><span style="color:#F97583"> &amp;&amp;</span><span style="color:#B392F0"> dest.x </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">            // Handle special case for bottom row</span></span>
<span class="line"><span style="color:#B392F0">            seq </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(seq, buildVerticalMoves(dy)</span><span style="color:#F97583">...</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">            seq </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(seq, buildHorizontalMoves(dx)</span><span style="color:#F97583">...</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#B392F0"> dx </span><span style="color:#F97583">&lt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">            // Prioritize left movements</span></span>
<span class="line"><span style="color:#B392F0">            seq </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(seq, buildHorizontalMoves(dx)</span><span style="color:#F97583">...</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">            seq </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(seq, buildVerticalMoves(dy)</span><span style="color:#F97583">...</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#6B737C">        // ... other movement cases</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">        curr </span><span style="color:#F97583">=</span><span style="color:#B392F0"> dest</span></span>
<span class="line"><span style="color:#B392F0">        seq </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(seq, </span><span style="color:#FFAB70">&quot;A&quot;</span><span style="color:#B392F0">) </span><span style="color:#6B737C">// Press the button</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> seq</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 threw us for a loop by increasing the chain of robots from 2 to 25! This meant our sequence
processing needed to handle many more layers of control. The key insight was using proper caching to
avoid recalculating sequences we’d seen before:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> countSequences(input []</span><span style="color:#F97583">string</span><span style="color:#B392F0">, maxRobots, robot </span><span style="color:#F97583">int</span><span style="color:#B392F0">, cache </span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">string</span><span style="color:#B392F0">][]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, dirMap </span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">string</span><span style="color:#B392F0">]Coord) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    key </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strings.Join(input, </span><span style="color:#FFAB70">&quot;&quot;</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> val, ok </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> cache[key]; ok </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> robot </span><span style="color:#F97583">&lt;=</span><span style="color:#B392F0"> len(val) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> val[robot</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">] </span><span style="color:#F97583">!=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#B392F0"> val[robot</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> _, ok </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> cache[key]; </span><span style="color:#F97583">!</span><span style="color:#B392F0">ok {</span></span>
<span class="line"><span style="color:#B392F0">        cache[key] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, maxRobots)</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#6B737C">    // ... process sequences and update cache</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-4">Thoughts</h3>
<p>Today’s puzzle was particularly devious in its complexity. What started as a seemingly
straightforward pathfinding problem quickly evolved into a multi-layered sequence optimization
challenge. The real difficulty wasn’t in finding a path through any single keypad - it was in
managing the cascading effects of each button press through multiple layers of robot control.</p>
<p>The most enlightening moment came when I realized we could treat each sequence as a series of
coordinate movements rather than trying to simulate the actual robot arm movements. This simplified
the logic considerably and made the caching strategy much more effective.</p>
<p>Performance was a significant concern, especially in Part 2 with its 25 layers of control. The
caching system was crucial here - without it, the combinatorial explosion of possible sequences
would have made the problem intractable.</p>
<p>I’d rate this a 9/10 difficulty. While the core concepts weren’t particularly exotic, the layered
nature of the problem and the need for efficient sequence handling made this one of the more
challenging puzzles so far. Getting everything working correctly while maintaining good performance
required careful thought and several iterations of the solution.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-20-race-condition">Day 20: Race Condition</h2>
<p>Today’s puzzle dropped us right outside a CPU for a race condition festival! We needed to help
programs navigate through a twisting code path while utilizing a special cheating mechanic. The
challenge involved pathfinding with an interesting twist - being able to pass through walls for a
limited time.</p>
<p>For Part 1, programs could cheat exactly once during a race, disabling collision for up to 2
picoseconds. I started by creating some basic structures to represent the grid and tracking
positions:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Pos </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    row, col </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Grid </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    cells    [][]</span><span style="color:#F97583">byte</span></span>
<span class="line"><span style="color:#B392F0">    start    Pos</span></span>
<span class="line"><span style="color:#B392F0">    end      Pos</span></span>
<span class="line"><span style="color:#B392F0">    rows     </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">    cols     </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core insight was that instead of trying to simulate the actual path with wall-passing, we could
first find the base distances to every reachable point using BFS:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> bfs(g Grid) </span><span style="color:#F97583">map</span><span style="color:#B392F0">[Pos]</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    distances </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[Pos]</span><span style="color:#F97583">int</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    q </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> []Pos{g.start}</span></span>
<span class="line"><span style="color:#B392F0">    distances[g.start] </span><span style="color:#F97583">=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> len(q) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        c </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> q[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">        q </span><span style="color:#F97583">=</span><span style="color:#B392F0"> q[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">:]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> _, m </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> moves {</span></span>
<span class="line"><span style="color:#B392F0">            n </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> Pos{c.row </span><span style="color:#F97583">+</span><span style="color:#B392F0"> m.row, c.col </span><span style="color:#F97583">+</span><span style="color:#B392F0"> m.col}</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#F97583"> !</span><span style="color:#B392F0">isInBounds(n, g) </span><span style="color:#F97583">||</span><span style="color:#B392F0"> g.cells[n.row][n.col] </span><span style="color:#F97583">==</span><span style="color:#FFAB70"> &#39;#&#39;</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">                continue</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> _, visited </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> distances[n]; </span><span style="color:#F97583">!</span><span style="color:#B392F0">visited {</span></span>
<span class="line"><span style="color:#B392F0">                distances[n] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> distances[c] </span><span style="color:#F97583">+</span><span style="color:#F8F8F8"> 1</span></span>
<span class="line"><span style="color:#B392F0">                q </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(q, n)</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> distances</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Then, for each position we can reach, we look at all positions within the cheat distance (2 steps
for Part 1) and calculate how much time we could save by jumping there. If we can reach that
position normally through the maze, the difference between the normal path length and the cheat path
length tells us how many picoseconds we save.</p>
<p>Part 2 simply increased the maximum cheat distance from 2 to 20 steps. The beauty of the solution is
that it required almost no changes - just updating the maximum skip distance value:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#B392F0">maxSkipDist </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 2</span><span style="color:#6B737C"> // default for part 1</span></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#B392F0"> part </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 2</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    maxSkipDist </span><span style="color:#F97583">=</span><span style="color:#F8F8F8"> 20</span><span style="color:#6B737C"> // increased skip distance for part 2</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-5">Thoughts</h3>
<p>Today’s puzzle was a fascinating exercise in thinking about pathfinding differently. Instead of
trying to simulate the actual paths with wall-passing (which would be much more complex), we could
solve it by finding normal path distances first and then calculating potential shortcuts.</p>
<p>The key insight was realizing we didn’t need to track the actual paths - we just needed to know if
positions were reachable and how many steps it would take to reach them normally. Then, any position
we could “jump” to that would save us steps represented a potential cheat opportunity.</p>
<p>Performance-wise, while we’re checking a lot of potential jump points, the solution remains
efficient because we only need to run the BFS once to get all the base distances. This made scaling
to Part 2’s larger jump distance trivial.</p>
<p>I’d rate this a 6/10 difficulty - while the core concept isn’t overwhelmingly complex, figuring out
the right approach took some careful thinking. The problem description initially leads you toward
trying to simulate actual paths with wall-passing, but finding the more elegant solution based on
calculating potential shortcuts made the problem much more manageable.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-19-linen-layout">Day 19: Linen Layout</h2>
<p>Today’s puzzle placed us at an onsen (Japanese hot spring) where we needed to help arrange towels
with colored stripe patterns. Each towel has a pattern of stripes (white, blue, black, red, or
green), and we needed to determine which designs could be created using combinations of available
towel patterns.</p>
<p>For Part 1, we needed to determine which designs were possible using any combination of the
available patterns. I used a recursive approach with memoization to solve this efficiently:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#B392F0">cache </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">string</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#B392F0"> solve </span><span style="color:#F97583">func</span><span style="color:#B392F0">(</span><span style="color:#F97583">string</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">solve </span><span style="color:#F97583">=</span><span style="color:#F97583"> func</span><span style="color:#B392F0">(s </span><span style="color:#F97583">string</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> _, ok </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> cache[s]; </span><span style="color:#F97583">!</span><span style="color:#B392F0">ok {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> len(s) </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#F8F8F8"> 1</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">        res </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> _, pattern </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> patterns {</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> strings.HasPrefix(s, </span><span style="color:#F97583">string</span><span style="color:#B392F0">(pattern)) {</span></span>
<span class="line"><span style="color:#B392F0">                res </span><span style="color:#F97583">+=</span><span style="color:#B392F0"> solve(s[len(pattern):])</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">        cache[s] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> res</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> cache[s]</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> _, design </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> designs {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> solve(design) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        out</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 added an interesting twist - instead of just checking if a design was possible, we needed to
count all the different ways each design could be created using the available patterns. Fortunately,
our recursive solution already handled this case! The key change was simply summing up the number of
ways each design could be made rather than just checking if it was possible.</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> _, design </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> designs {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> part </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 1</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> solve(design) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            out</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    } </span><span style="color:#F97583">else</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        out </span><span style="color:#F97583">+=</span><span style="color:#B392F0"> solve(design)</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The input parsing was straightforward, just splitting on newlines and commas:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> parseInput(input </span><span style="color:#F97583">string</span><span style="color:#B392F0">) ([]</span><span style="color:#F97583">string</span><span style="color:#B392F0">, []</span><span style="color:#F97583">string</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#B392F0">    s </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strings.Split(input, </span><span style="color:#FFAB70">&quot;\n\n&quot;</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> strings.Split(strings.TrimSpace(s[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]), </span><span style="color:#FFAB70">&quot;, &quot;</span><span style="color:#B392F0">), strings.Split(strings.TrimSpace(s[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]), </span><span style="color:#FFAB70">&quot;\n&quot;</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-6">Thoughts</h3>
<p>Today’s puzzle was relatively straightforward once you recognized it as a string matching problem
that could be solved recursively. The key insight was that we could break down each design into
smaller subproblems by trying each available pattern at the start of the remaining string. Using
memoization prevented us from recomputing the same substrings multiple times, making the solution
quite efficient.</p>
<p>Part 2 was particularly elegant because it didn’t require any algorithmic changes - our solution was
already counting all possible ways to create each design, we just needed to sum those counts instead
of checking if they were greater than zero.</p>
<p>I’d rate this a 3/10 difficulty - while it required some careful thinking about recursion and
memoization, the core concept was straightforward and the implementation was clean and concise.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-18-ram-run">Day 18: RAM Run</h2>
<p>Today’s puzzle placed us inside a computer’s memory space, trying to navigate through a grid while
avoiding corrupted memory locations. The challenge involved pathfinding through a dynamically
changing grid where bytes would “fall” and corrupt specific coordinates.</p>
<p>For Part 1, we needed to find the shortest path from <code>(0,0)</code> to <code>(70,70)</code> while avoiding corrupted
spaces after the first <code>1024</code> bytes had fallen. I implemented this using Dijkstra’s algorithm with a
priority queue for efficient path finding:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> findShortestPath(grid </span><span style="color:#F97583">map</span><span style="color:#B392F0">[Coord]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">, start, end Coord) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">    // init distances</span></span>
<span class="line"><span style="color:#B392F0">    dist </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[Coord]</span><span style="color:#F97583">int</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    dist[start] </span><span style="color:#F97583">=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // create a priority queue</span></span>
<span class="line"><span style="color:#B392F0">    pq </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(PQueue, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    heap.Init(</span><span style="color:#F97583">&amp;</span><span style="color:#B392F0">pq)</span></span>
<span class="line"><span style="color:#B392F0">    heap.Push(</span><span style="color:#F97583">&amp;</span><span style="color:#B392F0">pq, </span><span style="color:#F97583">&amp;</span><span style="color:#B392F0">Item{coord: start, priority: </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> pq.Len() </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        curr </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> heap.Pop(</span><span style="color:#F97583">&amp;</span><span style="color:#B392F0">pq).(</span><span style="color:#F97583">*</span><span style="color:#B392F0">Item)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // if we&#39;ve reached the end, return the distance</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> curr.coord </span><span style="color:#F97583">==</span><span style="color:#B392F0"> end {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#B392F0"> curr.priority</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // if we&#39;ve found a longer path to this point, skip</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> curr.priority </span><span style="color:#F97583">&gt;</span><span style="color:#B392F0"> dist[curr.coord] {</span></span>
<span class="line"><span style="color:#F97583">            continue</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // check all possible moves</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> _, dir </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> dirs {</span></span>
<span class="line"><span style="color:#B392F0">            next </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> Coord{curr.coord.x </span><span style="color:#F97583">+</span><span style="color:#B392F0"> dir.x, curr.coord.y </span><span style="color:#F97583">+</span><span style="color:#B392F0"> dir.y}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> isValidMove(next, grid, end) {</span></span>
<span class="line"><span style="color:#B392F0">                newDist </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> curr.priority </span><span style="color:#F97583">+</span><span style="color:#F8F8F8"> 1</span></span>
<span class="line"><span style="color:#F97583">                if</span><span style="color:#B392F0"> d, exists </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> dist[next]; </span><span style="color:#F97583">!</span><span style="color:#B392F0">exists </span><span style="color:#F97583">||</span><span style="color:#B392F0"> newDist </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> d {</span></span>
<span class="line"><span style="color:#B392F0">                    dist[next] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> newDist</span></span>
<span class="line"><span style="color:#B392F0">                    heap.Push(</span><span style="color:#F97583">&amp;</span><span style="color:#B392F0">pq, </span><span style="color:#F97583">&amp;</span><span style="color:#B392F0">Item{coord: next, priority: newDist})</span></span>
<span class="line"><span style="color:#B392F0">                }</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> -</span><span style="color:#F8F8F8">1</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 flipped the problem around - instead of finding a path through a fixed corruption pattern, we
needed to find the first byte that would make the path to the exit impossible. This required a
different approach using BFS to efficiently check for path existence after each byte falls:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> pathExists(grid </span><span style="color:#F97583">map</span><span style="color:#B392F0">[Coord]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">, start, end Coord) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    visited </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[Coord]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    queue </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> []Coord{start}</span></span>
<span class="line"><span style="color:#B392F0">    visited[start] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> len(queue) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        curr </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> queue[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">        queue </span><span style="color:#F97583">=</span><span style="color:#B392F0"> queue[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">:]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> curr </span><span style="color:#F97583">==</span><span style="color:#B392F0"> end {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> _, dir </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> dirs {</span></span>
<span class="line"><span style="color:#B392F0">            next </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> Coord{curr.coord.x </span><span style="color:#F97583">+</span><span style="color:#B392F0"> dir.x, curr.y </span><span style="color:#F97583">+</span><span style="color:#B392F0"> dir.y}</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> isValidMove(next, grid, end) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#F97583"> !</span><span style="color:#B392F0">visited[next] {</span></span>
<span class="line"><span style="color:#B392F0">                visited[next] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">                queue </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(queue, next)</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-7">Thoughts</h3>
<p>Today’s puzzle was an interesting mix of pathfinding algorithms. The key insight was recognizing
that while Dijkstra’s algorithm with a priority queue was ideal for finding the shortest path in
Part 1, a simpler BFS would be more efficient for Part 2 where we only needed to check if any path
existed.</p>
<p>The transition from Part 1 to Part 2 was particularly elegant - instead of processing all bytes at
once and finding a path, we needed to process bytes one at a time and check path existence after
each one. This made the problem more dynamic and required thinking about efficiency in a different
way.</p>
<p>Performance-wise, using a map to track corrupted spaces and implementing both Dijkstra’s and BFS
properly were crucial. The priority queue implementation helped Part 1 run efficiently, while the
simpler BFS approach in Part 2 avoided unnecessary complexity when we just needed to check path
existence.</p>
<p>I’d rate this a 5/10 difficulty - not overly complex conceptually, but requiring solid understanding
of different pathfinding algorithms and careful implementation to handle both parts efficiently.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-17-chronospatial-computer">Day 17: Chronospatial Computer</h2>
<p>Today’s puzzle involved implementing a unique 3-bit computer emulator. The challenge was to simulate
a computer with three registers (<code>A</code>, <code>B</code>, <code>C</code>) and eight different operations that use 3-bit
instructions and operands. I found this particularly interesting because it combined bitwise
operations with careful state management.</p>
<p>For Part 1, we needed to execute a program and collect its outputs. I started by creating structures
to parse the initial state and program. This was pretty straight forward, just parsing the input.</p>
<p>The core of the solution is the program execution logic. Each instruction consists of an <code>opcode</code>
and an <code>operand</code>, which we process in pairs:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> runProgram(a, b, c </span><span style="color:#F97583">int</span><span style="color:#B392F0">, program []</span><span style="color:#F97583">int</span><span style="color:#B392F0">) []</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    out </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> ip </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; ip </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(program); ip </span><span style="color:#F97583">+=</span><span style="color:#F8F8F8"> 2</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        opcode, operand </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> program[ip], program[ip</span><span style="color:#F97583">+</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // Process combo operand - this was tricky to understand at first</span></span>
<span class="line"><span style="color:#B392F0">        value </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> operand</span></span>
<span class="line"><span style="color:#F97583">        switch</span><span style="color:#B392F0"> operand {</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 4</span><span style="color:#B392F0">: value </span><span style="color:#F97583">=</span><span style="color:#B392F0"> a</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 5</span><span style="color:#B392F0">: value </span><span style="color:#F97583">=</span><span style="color:#B392F0"> b</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 6</span><span style="color:#B392F0">: value </span><span style="color:#F97583">=</span><span style="color:#B392F0"> c</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // Execute the instruction</span></span>
<span class="line"><span style="color:#F97583">        switch</span><span style="color:#B392F0"> opcode {</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">: </span><span style="color:#6B737C">// adv - divide A by 2^value (implemented as right shift)</span></span>
<span class="line"><span style="color:#B392F0">            a </span><span style="color:#F97583">&gt;&gt;=</span><span style="color:#B392F0"> value</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 1</span><span style="color:#B392F0">: </span><span style="color:#6B737C">// bxl - XOR B with literal operand</span></span>
<span class="line"><span style="color:#B392F0">            b </span><span style="color:#F97583">^=</span><span style="color:#B392F0"> operand  </span><span style="color:#6B737C">// Note: uses operand, not value!</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 2</span><span style="color:#B392F0">: </span><span style="color:#6B737C">// bst - set B to value mod 8</span></span>
<span class="line"><span style="color:#B392F0">            b </span><span style="color:#F97583">=</span><span style="color:#B392F0"> value </span><span style="color:#F97583">%</span><span style="color:#F8F8F8"> 8</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 3</span><span style="color:#B392F0">: </span><span style="color:#6B737C">// jnz - jump if A is not zero</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> a </span><span style="color:#F97583">!=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">                ip </span><span style="color:#F97583">=</span><span style="color:#B392F0"> operand </span><span style="color:#F97583">-</span><span style="color:#F8F8F8"> 2</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 4</span><span style="color:#B392F0">: </span><span style="color:#6B737C">// bxc - XOR B with C</span></span>
<span class="line"><span style="color:#B392F0">            b </span><span style="color:#F97583">^=</span><span style="color:#B392F0"> c</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 5</span><span style="color:#B392F0">: </span><span style="color:#6B737C">// out - output value mod 8</span></span>
<span class="line"><span style="color:#B392F0">            out </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(out, value</span><span style="color:#F97583">%</span><span style="color:#F8F8F8">8</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 6</span><span style="color:#B392F0">: </span><span style="color:#6B737C">// bdv - divide A by 2^value, store in B</span></span>
<span class="line"><span style="color:#B392F0">            b </span><span style="color:#F97583">=</span><span style="color:#B392F0"> a </span><span style="color:#F97583">&gt;&gt;</span><span style="color:#B392F0"> value</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#F8F8F8"> 7</span><span style="color:#B392F0">: </span><span style="color:#6B737C">// cdv - divide A by 2^value, store in C</span></span>
<span class="line"><span style="color:#B392F0">            c </span><span style="color:#F97583">=</span><span style="color:#B392F0"> a </span><span style="color:#F97583">&gt;&gt;</span><span style="color:#B392F0"> value</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> out</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 threw an interesting twist - we needed to find the lowest value for register A that would
make the program output itself. The approach involves building up the value bit by bit, using 3-bit
chunks (since it’s a 3-bit computer):</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#6B737C">// Part 2: Find lowest value of register A that makes program output itself</span></span>
<span class="line"><span style="color:#B392F0">a </span><span style="color:#F97583">=</span><span style="color:#F8F8F8"> 0</span><span style="color:#6B737C"> // the initial value doesn&#39;t matter here</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> pos </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> len(program) </span><span style="color:#F97583">-</span><span style="color:#F8F8F8"> 1</span><span style="color:#B392F0">; pos </span><span style="color:#F97583">&gt;=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; pos</span><span style="color:#F97583">--</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    a </span><span style="color:#F97583">&lt;&lt;=</span><span style="color:#F8F8F8"> 3</span><span style="color:#6B737C">  // shift left by 3 bits for each position</span></span>
<span class="line"><span style="color:#6B737C">    // Try values until we find one that outputs the correct sequence</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#F97583"> !</span><span style="color:#B392F0">slices.Equal(runProgram(a, b, c, program), program[pos:]) {</span></span>
<span class="line"><span style="color:#B392F0">        a</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-8">Thoughts</h3>
<p>This puzzle was fascinating because it required understanding both low-level computer architecture
concepts (instruction pointer, opcodes, operands) and bitwise operations. The trickiest parts were:</p>
<ol>
<li>Understanding the distinction between “combo” operands (which can reference register values) and
literal operands</li>
<li>Implementing the division operations using bit shifts (<code>&gt;&gt;=</code>)</li>
<li>Getting the jump instruction (<code>jnz</code>) to work correctly with the instruction pointer</li>
<li>Figuring out how to approach Part 2’s self-referential output requirement</li>
</ol>
<p>The key insight for Part 2 was realizing we could build the solution incrementally, working
backwards through the program and using 3-bit chunks to construct the final value. This works
because each instruction in the output must be a 3-bit number.</p>
<p>I’d rate this a 7/10 difficulty - while the individual operations weren’t too complex, understanding
the problem specification and figuring out the approach for Part 2 required careful thinking. The
fact that we’re working with a 3-bit computer architecture also meant keeping track of several
important details about how values should be processed and stored.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-16-reindeer-maze">Day 16: Reindeer Maze</h2>
<p>Today’s puzzle involved helping reindeer navigate through a maze in the most efficient way possible.
Each reindeer starts on a start tile (<code>S</code>) facing east and needs to reach an end tile (<code>E</code>). The
twist is that movement costs vary dramatically - moving forward costs just 1 point, but rotating 90
degrees costs a whopping 1000 points!</p>
<p>For Part 1, I needed to find the path with the lowest possible score. I started by creating some
basic types to represent the maze and movement:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Point </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    x, y </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Direction </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    dx, dy </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Maze </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    grid  [][]</span><span style="color:#F97583">string</span></span>
<span class="line"><span style="color:#B392F0">    start Point</span></span>
<span class="line"><span style="color:#B392F0">    end   Point</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core of the solution uses a sort of janky priority queue to always process the paths with lowest
scores first. This ensures we find the optimal path:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> len(q) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    sort.Slice(q, </span><span style="color:#F97583">func</span><span style="color:#B392F0">(i, j </span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#B392F0"> q[i].score </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> q[j].score</span></span>
<span class="line"><span style="color:#B392F0">    })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    current </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> q[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">    q </span><span style="color:#F97583">=</span><span style="color:#B392F0"> q[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">:]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> current.pos </span><span style="color:#F97583">==</span><span style="color:#B392F0"> end {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#B392F0"> current.score</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // Try moving forward and turning...</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 threw an interesting twist at us - instead of just finding the lowest score path, we needed
to find how many tiles appear in ANY path that achieves the lowest score. This required tracking
complete paths and being careful about how we count unique positions:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> QueueItem </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    pos   Point</span></span>
<span class="line"><span style="color:#B392F0">    dir   </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">    score </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">    path  []Point  </span><span style="color:#6B737C">// Now we need to track the full path</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The key insight was that we needed to use the same pathfinding approach twice - once to find the
minimum score, and again to collect all paths that achieve that score. Then we could count unique
positions across all those paths:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#B392F0">ls </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> findLowestScore(maze)</span></span>
<span class="line"><span style="color:#B392F0">paths </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> findAllOptimalPaths(maze, ls)</span></span>
<span class="line"><span style="color:#F97583">return</span><span style="color:#B392F0"> countUniqueTiles(paths)</span></span></code></pre>
<h3 id="thoughts-9">Thoughts</h3>
<p>Today’s puzzle was an interesting exercise in pathfinding with some unique constraints. The huge
cost difference between moving forward and turning made for some interesting path optimization, and
Part 2’s requirement to find ALL optimal paths added another layer of complexity.</p>
<p>A key insight that saved some headaches was realizing that since turns cost 1000 while moves cost 1,
any path with an extra turn would always be worse than a path with fewer turns, regardless of how
many extra forward moves it saved.</p>
<p>I’d rate this a 6/10 difficulty - while the core pathfinding concepts weren’t too exotic, getting
all the pieces working together correctly required careful implementation and debugging. The
transition from Part 1 to Part 2 was particularly interesting, requiring us to adapt our solution to
track and analyze multiple optimal paths.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-15-warehouse-woes">Day 15: Warehouse Woes</h2>
<p>Today’s puzzle was about helping lanternfish with their warehouse robot problem. We had to predict
the movements of a malfunctioning robot pushing boxes around in a warehouse. The robot follows a
sequence of moves (<code>^</code>, <code>v</code>, <code>&lt;</code>, <code>&gt;</code>), and when it encounters boxes, it attempts to push them -
unless doing so would cause the robot or a box to hit a wall.</p>
<p>For Part 1, I started by creating structures to represent the warehouse and implementing recursive
movement logic for pushing chains of boxes:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Warehouse </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    moveSeq </span><span style="color:#F97583">string</span></span>
<span class="line"><span style="color:#B392F0">    boxes   </span><span style="color:#F97583">map</span><span style="color:#B392F0">[Pair]</span><span style="color:#F97583">struct</span><span style="color:#B392F0">{}</span></span>
<span class="line"><span style="color:#B392F0">    robot   Pair</span></span>
<span class="line"><span style="color:#B392F0">    walls   </span><span style="color:#F97583">map</span><span style="color:#B392F0">[Pair]</span><span style="color:#F97583">struct</span><span style="color:#B392F0">{}</span></span>
<span class="line"><span style="color:#B392F0">    width   </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">    height  </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> moveBoxes(w </span><span style="color:#F97583">*</span><span style="color:#B392F0">Warehouse, box Pair, dir </span><span style="color:#F97583">byte</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#B392F0">    next </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> getNextPair(box, dir)</span></span>
<span class="line"><span style="color:#B392F0">    _, isBox </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> w.boxes[next]</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> isBox {</span></span>
<span class="line"><span style="color:#B392F0">        moveBoxes(w, next, dir)</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">    delete(w.boxes, box)</span></span>
<span class="line"><span style="color:#B392F0">    w.boxes[next] </span><span style="color:#F97583">=</span><span style="color:#F97583"> struct</span><span style="color:#B392F0">{}{}</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 threw a fascinating twist at us - everything except the robot was now twice as wide! Each
original box (<code>O</code>) became a wide box (<code>[]</code>), and walls (<code>#</code>) became double walls (<code>##</code>). Instead of
modifying my Part 1 solution, I created new structures specifically for Part 2:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> BigBox </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    left  Pair</span></span>
<span class="line"><span style="color:#B392F0">    right Pair</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> BigWarehouse </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    boxes    </span><span style="color:#F97583">map</span><span style="color:#B392F0">[BigBox]</span><span style="color:#F97583">struct</span><span style="color:#B392F0">{}</span></span>
<span class="line"><span style="color:#B392F0">    boxParts </span><span style="color:#F97583">map</span><span style="color:#B392F0">[Pair]BigBox</span></span>
<span class="line"><span style="color:#B392F0">    robot    Pair</span></span>
<span class="line"><span style="color:#6B737C">    // ... other fields</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-10">Thoughts</h3>
<p>Today’s puzzle was a fascinating exercise in state management and spatial reasoning. The tricky part
wasn’t just tracking positions - it was managing the complex interactions between boxes, especially
in Part 2 where boxes could push multiple other boxes at once due to their width. The key insight
was realizing that Part 2 needed a completely different approach rather than trying to modify
Part 1. Using separate data structures for wide boxes and handling horizontal/vertical movements
differently made the solution much clearer. Getting all the edge cases right and ensuring proper box
chain movements took quite a bit of debugging.</p>
<p>I’d rate this an 8/10 difficulty. While the concept was straightforward, implementing all the
movement rules correctly and handling the wide boxes in Part 2 required careful thought and
significant refactoring.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-14-restroom-redoubt">Day 14: Restroom Redoubt</h2>
<p>Today’s puzzle was about predicting robot movement patterns in a bounded space. We needed to track
multiple robots moving in straight lines that would wrap around the edges of the area, like a game
of Snake meets Conway’s Game of Life.</p>
<p>For Part 1, we had to simulate the robots’ movement for 100 seconds and calculate a “safety factor”
based on their final positions in each quadrant. I started by creating basic structures to represent
the robots and their movement:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Coordinate </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    x, y </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Robot </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    pos Coordinate </span><span style="color:#6B737C">// position</span></span>
<span class="line"><span style="color:#B392F0">    vel Coordinate </span><span style="color:#6B737C">// velocity</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core simulation logic involves moving each robot according to its velocity and handling the
wrapping behavior when they hit the edges. The trick here was getting the modulo arithmetic right to
handle negative positions correctly:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> moveRobots(robots []Robot) {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> robots {</span></span>
<span class="line"><span style="color:#6B737C">        // Update position</span></span>
<span class="line"><span style="color:#B392F0">        robots[i].pos.x </span><span style="color:#F97583">+=</span><span style="color:#B392F0"> robots[i].vel.x</span></span>
<span class="line"><span style="color:#B392F0">        robots[i].pos.y </span><span style="color:#F97583">+=</span><span style="color:#B392F0"> robots[i].vel.y</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // Handle wrapping</span></span>
<span class="line"><span style="color:#B392F0">        robots[i].pos.x </span><span style="color:#F97583">=</span><span style="color:#B392F0"> ((robots[i].pos.x </span><span style="color:#F97583">%</span><span style="color:#F8F8F8"> 101</span><span style="color:#B392F0">) </span><span style="color:#F97583">+</span><span style="color:#F8F8F8"> 101</span><span style="color:#B392F0">) </span><span style="color:#F97583">%</span><span style="color:#F8F8F8"> 101</span></span>
<span class="line"><span style="color:#B392F0">        robots[i].pos.y </span><span style="color:#F97583">=</span><span style="color:#B392F0"> ((robots[i].pos.y </span><span style="color:#F97583">%</span><span style="color:#F8F8F8"> 103</span><span style="color:#B392F0">) </span><span style="color:#F97583">+</span><span style="color:#F8F8F8"> 103</span><span style="color:#B392F0">) </span><span style="color:#F97583">%</span><span style="color:#F8F8F8"> 103</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>After simulating 100 seconds, we need to count robots in each quadrant, being careful to exclude
robots on the middle lines.</p>
<p>Part 2 introduced an interesting twist - we needed to find when the robots would form a pattern
resembling a Christmas tree. The key insight was looking for long horizontal lines of robots, which
would form part of the tree pattern:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> hasLongHorizontalLine(robots []Robot) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">    // Count robots in each row</span></span>
<span class="line"><span style="color:#B392F0">    rowCounts </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#F8F8F8"> 103</span><span style="color:#B392F0">; i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        rowCounts[i] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // Record robot positions by row</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> _, robot </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> robots {</span></span>
<span class="line"><span style="color:#B392F0">        rowCounts[robot.pos.y][robot.pos.x] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // Look for a row with many robots and long consecutive sequences</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> y </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; y </span><span style="color:#F97583">&lt;</span><span style="color:#F8F8F8"> 103</span><span style="color:#B392F0">; y</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> len(rowCounts[y]) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 30</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            consecutive </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#B392F0"> x </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; x </span><span style="color:#F97583">&lt;</span><span style="color:#F8F8F8"> 100</span><span style="color:#B392F0">; x</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">                if</span><span style="color:#B392F0"> rowCounts[y][x] </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> rowCounts[y][x</span><span style="color:#F97583">+</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">] {</span></span>
<span class="line"><span style="color:#B392F0">                    consecutive</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#F97583">                    if</span><span style="color:#B392F0"> consecutive </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 25</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">                        return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">                    }</span></span>
<span class="line"><span style="color:#B392F0">                } </span><span style="color:#F97583">else</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">                    consecutive </span><span style="color:#F97583">=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"><span style="color:#B392F0">                }</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-11">Thoughts</h3>
<p>Today’s puzzle combined several interesting concepts - coordinate systems, modular arithmetic, and
pattern recognition.</p>
<p>The key insight for Part 2 was realizing that the Christmas tree pattern would necessarily involve
long horizontal lines of robots. Instead of trying to detect the entire tree shape, we could just
look for these characteristic lines.</p>
<p>I’d rate this a 6/10 difficulty. While the core concepts weren’t overwhelmingly complex, getting all
the details right - especially the wrapping behavior and pattern detection - required careful
implementation and debugging. The transition from Part 1 to Part 2 was particularly interesting,
requiring us to think about the problem in a completely different way.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-13-claw-contraption">Day 13: Claw Contraption</h2>
<p>Today’s puzzle involved solving a system of linear equations to determine optimal button press
sequences for arcade claw machines. We needed to calculate the minimum number of tokens required to
win prizes by manipulating a claw along X and Y coordinates using two buttons with different costs
and movement patterns.</p>
<p>For Part 1, I initially implemented a brute force solution, checking all possible combinations of
button presses up to 100:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> ClawMachine </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    btnA  Coordinate</span></span>
<span class="line"><span style="color:#B392F0">    btnB  Coordinate</span></span>
<span class="line"><span style="color:#B392F0">    prize Coordinate</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> bruteCalculateTokens(machine </span><span style="color:#F97583">*</span><span style="color:#B392F0">ClawMachine) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> a </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; a </span><span style="color:#F97583">&lt;=</span><span style="color:#F8F8F8"> 100</span><span style="color:#B392F0">; a</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> b </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; b </span><span style="color:#F97583">&lt;=</span><span style="color:#F8F8F8"> 100</span><span style="color:#B392F0">; b</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            xPos </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> a</span><span style="color:#F97583">*</span><span style="color:#B392F0">machine.btnA.x </span><span style="color:#F97583">+</span><span style="color:#B392F0"> b</span><span style="color:#F97583">*</span><span style="color:#B392F0">machine.btnB.x</span></span>
<span class="line"><span style="color:#B392F0">            yPos </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> a</span><span style="color:#F97583">*</span><span style="color:#B392F0">machine.btnA.y </span><span style="color:#F97583">+</span><span style="color:#B392F0"> b</span><span style="color:#F97583">*</span><span style="color:#B392F0">machine.btnB.y</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> xPos </span><span style="color:#F97583">==</span><span style="color:#B392F0"> machine.prize.x </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> yPos </span><span style="color:#F97583">==</span><span style="color:#B392F0"> machine.prize.y {</span></span>
<span class="line"><span style="color:#F97583">                return</span><span style="color:#B392F0"> (</span><span style="color:#F8F8F8">3</span><span style="color:#F97583"> *</span><span style="color:#B392F0"> a) </span><span style="color:#F97583">+</span><span style="color:#B392F0"> b  </span><span style="color:#6B737C">// 3 tokens per A press, 1 per B press</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 introduced a significant twist - all prize coordinates were offset by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>13</mn></msup></mrow><annotation encoding="application/x-tex">10^{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span></span></span></span> units, making
the brute force approach impractical. This required a more mathematical solution using Cramer’s Rule
to solve the system of linear equations:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> solveEquation(m </span><span style="color:#F97583">*</span><span style="color:#B392F0">ClawMachine) (</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F97583">int</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#6B737C">    // Using Cramer&#39;s Rule to solve:</span></span>
<span class="line"><span style="color:#6B737C">    // ax*A + bx*B = px (x equation)</span></span>
<span class="line"><span style="color:#6B737C">    // ay*A + by*B = py (y equation)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    d </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> m.btnA.x</span><span style="color:#F97583">*</span><span style="color:#B392F0">m.btnB.y </span><span style="color:#F97583">-</span><span style="color:#B392F0"> m.btnA.y</span><span style="color:#F97583">*</span><span style="color:#B392F0">m.btnB.x</span></span>
<span class="line"><span style="color:#B392F0">    d1 </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> m.prize.x</span><span style="color:#F97583">*</span><span style="color:#B392F0">m.btnB.y </span><span style="color:#F97583">-</span><span style="color:#B392F0"> m.prize.y</span><span style="color:#F97583">*</span><span style="color:#B392F0">m.btnB.x</span></span>
<span class="line"><span style="color:#B392F0">    d2 </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> m.prize.y</span><span style="color:#F97583">*</span><span style="color:#B392F0">m.btnA.x </span><span style="color:#F97583">-</span><span style="color:#B392F0"> m.prize.x</span><span style="color:#F97583">*</span><span style="color:#B392F0">m.btnA.y</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // Check if we have integer solutions</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> d1</span><span style="color:#F97583">%</span><span style="color:#B392F0">d </span><span style="color:#F97583">!=</span><span style="color:#F8F8F8"> 0</span><span style="color:#F97583"> ||</span><span style="color:#B392F0"> d2</span><span style="color:#F97583">%</span><span style="color:#B392F0">d </span><span style="color:#F97583">!=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> d1</span><span style="color:#F97583">/</span><span style="color:#B392F0">d, d2</span><span style="color:#F97583">/</span><span style="color:#B392F0">d</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-12">Thoughts</h3>
<p>The key insight was recognizing this as a linear system that could be solved efficiently using
linear algebra rather than exhaustive search. Having recently studied Cramer’s Rule for a linear
algebra final proved unexpectedly useful for this implementation.</p>
<p>I’d rate this a 3/10 difficulty - the entire thing was fairly straight forward. The hardest part was
figuring out how to calculate part 2. Once I remembered the linear algebra I was just studying, it
was super easy.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-12-garden-groups">Day 12: Garden Groups</h2>
<p>Today’s puzzle was all about analyzing connected regions in a grid - specifically, garden plots that
form regions when they contain the same type of plant. The challenge involved calculating areas and
boundaries of these regions, with some clever twists in how boundaries are counted between parts 1
and 2.</p>
<p>For Part 1, we needed to find connected regions of same-letter plants and calculate their area
multiplied by their perimeter. I approached this using a flood-fill algorithm with some careful
boundary tracking:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Garden </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    symbol     </span><span style="color:#F97583">rune</span></span>
<span class="line"><span style="color:#B392F0">    size       </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">    coords     </span><span style="color:#F97583">map</span><span style="color:#B392F0">[Coord]</span><span style="color:#F97583">bool</span></span>
<span class="line"><span style="color:#B392F0">    boundaries </span><span style="color:#F97583">map</span><span style="color:#B392F0">[Direction][]boundary</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core insight was that we needed to track not just the coordinates in each region, but also their
boundaries in each cardinal direction. This made calculating perimeters much more straightforward:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> checkBoundary(grid [][]</span><span style="color:#F97583">rune</span><span style="color:#B392F0">, pos Coord, symbol </span><span style="color:#F97583">rune</span><span style="color:#B392F0">, dir Direction, garden </span><span style="color:#F97583">*</span><span style="color:#B392F0">Garden) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#B392F0"> isEdge </span><span style="color:#F97583">bool</span></span>
<span class="line"><span style="color:#F97583">    switch</span><span style="color:#B392F0"> dir {</span></span>
<span class="line"><span style="color:#F97583">    case</span><span style="color:#B392F0"> North:</span></span>
<span class="line"><span style="color:#B392F0">        isEdge </span><span style="color:#F97583">=</span><span style="color:#B392F0"> pos.row </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 0</span><span style="color:#F97583"> ||</span><span style="color:#B392F0"> grid[pos.row</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">][pos.col] </span><span style="color:#F97583">!=</span><span style="color:#B392F0"> symbol</span></span>
<span class="line"><span style="color:#6B737C">        // Similar cases for other directions...</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> isEdge {</span></span>
<span class="line"><span style="color:#B392F0">        garden.boundaries[dir] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(garden.boundaries[dir], boundary{pos.row, pos.col, </span><span style="color:#79B8FF">true</span><span style="color:#B392F0">})</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 introduced a fascinating twist - instead of using the perimeter length, we needed to count
distinct “sides” of each region. This meant that a complex shape like an ‘E’ would have many more
sides than its perimeter length might suggest. The trick was to modify how we count boundaries:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> prune(garden </span><span style="color:#F97583">*</span><span style="color:#B392F0">Garden) {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> dir </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> garden.boundaries {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> dir </span><span style="color:#F97583">==</span><span style="color:#B392F0"> North </span><span style="color:#F97583">||</span><span style="color:#B392F0"> dir </span><span style="color:#F97583">==</span><span style="color:#B392F0"> South {</span></span>
<span class="line"><span style="color:#B392F0">            prune(garden.boundaries[dir], </span><span style="color:#79B8FF">true</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        } </span><span style="color:#F97583">else</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            prune(garden.boundaries[dir], </span><span style="color:#79B8FF">false</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The most challenging aspect was handling regions that contained “holes” - other regions entirely
enclosed within them. This required careful boundary counting to ensure we didn’t double-count
shared edges while still properly accounting for interior boundaries.</p>
<p>Today’s solution is quite lengthy, so I haven’t included it here. You can find it on my
<a href="https://github.com/dickeyy/adventofcode/blob/main/2024/day-12/main.go">GitHub</a>.</p>
<h3 id="thoughts-13">Thoughts</h3>
<p>Today’s puzzle was a fascinating exercise in geometric reasoning and boundary detection. The main
challenges were:</p>
<ol>
<li>Implementing a robust flood-fill algorithm that could properly identify connected regions</li>
<li>Tracking boundaries efficiently without double-counting shared edges</li>
<li>Making the mental shift from perimeter-based counting in Part 1 to side-based counting in Part 2</li>
<li>Handling edge cases like regions with holes or regions that touch only at corners</li>
</ol>
<p>The key insight that really unlocked the solution was realizing that we needed to track boundaries
per direction rather than just as a simple count. This made it much easier to handle both the
perimeter calculation in Part 1 and the side counting in Part 2.</p>
<p>I’d rate this an 8/10 difficulty - while the core concepts weren’t overwhelmingly complex, getting
all the boundary detection and counting logic correct was tough. The transition from Part 1 to Part
2 was particularly clever, forcing us to completely rethink how we counted boundaries while still
using much of the same underlying region detection code.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-11-plutonian-pebbles">Day 11: Plutonian Pebbles</h2>
<p>Today’s puzzle involved some physics-defying stones that transform based on simple rules whenever
you blink. Each stone has a number, and depending on whether it’s 0, has an even number of digits,
or neither, it will either become 1, split into two stones, or multiply by 2024.</p>
<p>For Part 1, we need to simulate 25 “blinks” and count how many stones we end up with. My first
approach was pretty straightforward - just track each stone in a slice and apply the
transformations:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> blink(stones []</span><span style="color:#F97583">int</span><span style="color:#B392F0">) []</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    newStones </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> _, stone </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> stones {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> stone </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            newStones </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(newStones, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#B392F0"> countDigitsInNumber(stone)</span><span style="color:#F97583">%</span><span style="color:#F8F8F8">2</span><span style="color:#F97583"> ==</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            left, right </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> splitNumberIntoHalves(stone)</span></span>
<span class="line"><span style="color:#B392F0">            newStones </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(newStones, left, right)</span></span>
<span class="line"><span style="color:#B392F0">        } </span><span style="color:#F97583">else</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            newStones </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(newStones, stone</span><span style="color:#F97583">*</span><span style="color:#F8F8F8">2024</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> newStones</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>This worked fine for Part 1, but when Part 2 asked for 75 iterations, the exponential growth of
stones made this approach impractical. After some thinking, I realized I could optimize by tracking
frequencies instead of individual stones. This led to recasting the problem in terms of stone
counts:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> day11(input </span><span style="color:#F97583">string</span><span style="color:#B392F0">, part </span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    s </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> utils.GetIntsInString(input)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // count freq of each stone val</span></span>
<span class="line"><span style="color:#B392F0">    scs </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> _, s </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> s {</span></span>
<span class="line"><span style="color:#B392F0">        scs[s]</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    iters </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 25</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> part </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 2</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        iters </span><span style="color:#F97583">=</span><span style="color:#F8F8F8"> 75</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // process stones</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> iters; i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        scs </span><span style="color:#F97583">=</span><span style="color:#B392F0"> blinkAllStones(scs)</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> sumStones(scs)</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core transformation logic became simpler too, just handling one stone value at a time:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> blinkOnce(stone </span><span style="color:#F97583">int</span><span style="color:#B392F0">) []</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> stone </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#B392F0"> []</span><span style="color:#F97583">int</span><span style="color:#B392F0">{</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">}</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // convert to string to check digits</span></span>
<span class="line"><span style="color:#B392F0">    s </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strconv.Itoa(stone)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> len(s)</span><span style="color:#F97583">%</span><span style="color:#F8F8F8">2</span><span style="color:#F97583"> ==</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">        // split into two halves</span></span>
<span class="line"><span style="color:#B392F0">        halfway </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> len(s) </span><span style="color:#F97583">/</span><span style="color:#F8F8F8"> 2</span></span>
<span class="line"><span style="color:#B392F0">        l </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> utils.AtoiNoErr(s[:halfway])</span></span>
<span class="line"><span style="color:#B392F0">        r </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> utils.AtoiNoErr(s[halfway:])</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#B392F0"> []</span><span style="color:#F97583">int</span><span style="color:#B392F0">{l, r}</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> []</span><span style="color:#F97583">int</span><span style="color:#B392F0">{stone </span><span style="color:#F97583">*</span><span style="color:#F8F8F8"> 2024</span><span style="color:#B392F0">}</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>With the <code>blinkAllStones</code> function looking like this:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> blinkAllStones(stoneCount </span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    nc </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> s, c </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> stoneCount {</span></span>
<span class="line"><span style="color:#6B737C">        // get new stones from transformation</span></span>
<span class="line"><span style="color:#B392F0">        ns </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> blinkOnce(s)</span></span>
<span class="line"><span style="color:#6B737C">        // add to counts, multiplied by how many of oritinal stones we had</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> _, n </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> ns {</span></span>
<span class="line"><span style="color:#B392F0">            nc[n] </span><span style="color:#F97583">+=</span><span style="color:#B392F0"> c</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> nc</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-14">Thoughts</h3>
<p>Today’s puzzle was all about finding the right way to represent the data. While the initial
slice-based approach worked, the frequency map solution was much more elegant and efficient. It’s a
good reminder that sometimes you need to step back and rethink your approach when scaling becomes an
issue.</p>
<p>I’d rate this a 3/10 difficulty - the concept itself isn’t particularly challenging, but recognizing
the need to optimize and implementing the frequency-based solution required some careful thinking.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-10-hoof-it">Day 10: Hoof It</h2>
<p>In today’s Advent of Code puzzle, we were tasked with analyzing a topographic map of a hiking area
on a floating island. The map indicated the height of each position using a scale from 0 (lowest) to
9 (highest). Our goal was to find all the trailheads and calculate two different metrics for each
one.</p>
<p>For Part 1, we needed to find the trailheads (any position with a height of 0) and calculate a
“score” for each one. The score was defined as the number of positions with a height of 9 that were
reachable from that trailhead via a hiking trail. A hiking trail was any path that started at height
0, ended at height 9, and increased by exactly 1 in height at each step.</p>
<p>To solve this, I first parsed the input into a 2D grid representing the topographic map. I then
implemented a breadth-first search (BFS) algorithm, starting from each trailhead and exploring all
valid paths. Whenever I reached a height 9 position, I incremented the trailhead’s score. The sum of
all the trailhead scores was the final answer for Part 1.</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> bfs(grid [][]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, start [</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    directions </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> [][</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">{{</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">}, {</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">}, {</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">, </span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">}, {</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">}}</span></span>
<span class="line"><span style="color:#B392F0">    queue </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> [][</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">{start}</span></span>
<span class="line"><span style="color:#B392F0">    visited </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[[</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    visited[start] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">    score </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> len(queue) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        curr </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> queue[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">        queue </span><span style="color:#F97583">=</span><span style="color:#B392F0"> queue[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">:]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> _, d </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> directions {</span></span>
<span class="line"><span style="color:#B392F0">            ni, nj </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> curr[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]</span><span style="color:#F97583">+</span><span style="color:#B392F0">d[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">], curr[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]</span><span style="color:#F97583">+</span><span style="color:#B392F0">d[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> ni </span><span style="color:#F97583">&gt;=</span><span style="color:#F8F8F8"> 0</span><span style="color:#F97583"> &amp;&amp;</span><span style="color:#B392F0"> ni </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(grid) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> nj </span><span style="color:#F97583">&gt;=</span><span style="color:#F8F8F8"> 0</span><span style="color:#F97583"> &amp;&amp;</span><span style="color:#B392F0"> nj </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(grid[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]) {</span></span>
<span class="line"><span style="color:#B392F0">                next </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> [</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">{ni, nj}</span></span>
<span class="line"><span style="color:#F97583">                if</span><span style="color:#F97583"> !</span><span style="color:#B392F0">visited[next] </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> grid[ni][nj] </span><span style="color:#F97583">==</span><span style="color:#B392F0"> grid[curr[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]][curr[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]]</span><span style="color:#F97583">+</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">                    visited[next] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">                    queue </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(queue, next)</span></span>
<span class="line"><span style="color:#F97583">                    if</span><span style="color:#B392F0"> grid[ni][nj] </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 9</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">                        score</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">                    }</span></span>
<span class="line"><span style="color:#B392F0">                }</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> score</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 introduced a new metric called the “rating” of a trailhead. The rating was defined as the
number of distinct hiking trails that began at that trailhead. To solve this, I used a recursive
depth-first search (DFS) approach, tracking the visited positions and direction at each step to
detect when a new valid trail was found.</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> countPaths(grid [][]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, pos [</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, visited </span><span style="color:#F97583">map</span><span style="color:#B392F0">[[</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> grid[pos[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]][pos[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]] </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 9</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#F8F8F8"> 1</span><span style="color:#6B737C"> // reached the end of a valid path</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    directions </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> [][</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">{{</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">}, {</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">}, {</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">, </span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">}, {</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">}}</span></span>
<span class="line"><span style="color:#B392F0">    visited[pos] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">    totalPaths </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> _, d </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> directions {</span></span>
<span class="line"><span style="color:#B392F0">        ni, nj </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> pos[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]</span><span style="color:#F97583">+</span><span style="color:#B392F0">d[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">], pos[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]</span><span style="color:#F97583">+</span><span style="color:#B392F0">d[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">        next </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> [</span><span style="color:#F8F8F8">2</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">{ni, nj}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // check bounds and ensure path increment is valid</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> ni </span><span style="color:#F97583">&gt;=</span><span style="color:#F8F8F8"> 0</span><span style="color:#F97583"> &amp;&amp;</span><span style="color:#B392F0"> ni </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(grid) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> nj </span><span style="color:#F97583">&gt;=</span><span style="color:#F8F8F8"> 0</span><span style="color:#F97583"> &amp;&amp;</span><span style="color:#B392F0"> nj </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(grid[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]) {</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#F97583"> !</span><span style="color:#B392F0">visited[next] </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> grid[ni][nj] </span><span style="color:#F97583">==</span><span style="color:#B392F0"> grid[pos[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]][pos[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]]</span><span style="color:#F97583">+</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">                totalPaths </span><span style="color:#F97583">+=</span><span style="color:#B392F0"> countPaths(grid, next, visited)</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    visited[pos] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#6B737C"> // backtrack</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> totalPaths</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-15">Thoughts</h3>
<p>Today’s puzzle was an interesting challenge in graph traversal and state management. While the core
concepts weren’t overly complex, implementing the solutions correctly and efficiently required some
careful thinking.</p>
<p>The trickiest part was definitely the transition from Part 1 to Part 2. Part 1’s BFS approach was
relatively straightforward, but Part 2’s DFS-based path counting introduced a lot more complexity.
Keeping track of the visited positions and direction changes to avoid duplicates was key, and it
took some debugging to get the recursive logic right.</p>
<p>Performance-wise, both solutions are reasonably efficient, with the BFS approach in Part 1 running
in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> time and the DFS in Part 2 running in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mstyle mathcolor="#cc0000"><mtext>\*</mtext></mstyle><msup><mn>3</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \* 3^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\*</span></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> time (where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> is the number of
positions in the grid). However, the memory usage for Part 2 could be a concern for larger inputs,
as we’re recursively exploring all possible paths.</p>
<p>Overall, I’d rate this puzzle a 4/10 in difficulty. The concepts weren’t overly complex, but the
implementation details and the transition from Part 1 to Part 2 added a decent challenge. It was a
good exercise in graph algorithms and state management, and I enjoyed the problem-solving aspect of
it.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-9-disk-fragmenter">Day 9: Disk Fragmenter</h2>
<p>Today’s puzzle was about helping an amphipod compact files on a disk. The challenge involved
interpreting a dense disk map format and implementing file movement algorithms. What made this
particularly interesting was the need to track file IDs and carefully manage block-by-block
movements in Part 1, then switch to whole-file movements in Part 2.</p>
<p>For Part 1, we needed to move individual blocks from the rightmost files to the leftmost free
spaces, maintaining file order and calculating a checksum based on positions. Here’s how I
approached parsing the disk map and creating the initial state:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Disk </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    Blocks []</span><span style="color:#F97583">int</span><span style="color:#6B737C"> // -1 represents free space, non-negative numbers represent file IDs</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> parseDiskMap(input </span><span style="color:#F97583">string</span><span style="color:#B392F0">) ([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, []</span><span style="color:#F97583">int</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#B392F0">    files </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    spaces </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(input); i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        size </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> utils.AtoiNoErr(</span><span style="color:#F97583">string</span><span style="color:#B392F0">(input[i]))</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> i</span><span style="color:#F97583">%</span><span style="color:#F8F8F8">2</span><span style="color:#F97583"> ==</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            files </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(files, size)</span></span>
<span class="line"><span style="color:#B392F0">        } </span><span style="color:#F97583">else</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            spaces </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(spaces, size)</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> files, spaces</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> createInitialDisk(files, spaces []</span><span style="color:#F97583">int</span><span style="color:#B392F0">) Disk {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#B392F0"> blocks []</span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">    fileID </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(files); i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">        // add file blocks</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> j </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; j </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> files[i]; j</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            blocks </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(blocks, fileID)</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">        fileID</span><span style="color:#F97583">++</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // add free space</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(spaces) {</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#B392F0"> j </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; j </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> spaces[i]; j</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">                blocks </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(blocks, </span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> Disk{Blocks: blocks}</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core of Part 1 involved finding the rightmost file block and the leftmost free space, then
moving blocks one at a time:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> (d </span><span style="color:#F97583">*</span><span style="color:#B392F0">Disk) findFirstFreeSpace() </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i, block </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> d.Blocks {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> block </span><span style="color:#F97583">==</span><span style="color:#F97583"> -</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#B392F0"> i</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> -</span><span style="color:#F8F8F8">1</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> (d </span><span style="color:#F97583">*</span><span style="color:#B392F0">Disk) findLastFileBlock() </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> len(d.Blocks) </span><span style="color:#F97583">-</span><span style="color:#F8F8F8"> 1</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&gt;=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i</span><span style="color:#F97583">--</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> d.Blocks[i] </span><span style="color:#F97583">!=</span><span style="color:#F97583"> -</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#B392F0"> i</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> -</span><span style="color:#F8F8F8">1</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> (d </span><span style="color:#F97583">*</span><span style="color:#B392F0">Disk) moveOneBlock(fromIndex, toIndex </span><span style="color:#F97583">int</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#B392F0">    fileID </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> d.Blocks[fromIndex]</span></span>
<span class="line"><span style="color:#B392F0">    d.Blocks[fromIndex] </span><span style="color:#F97583">=</span><span style="color:#F97583"> -</span><span style="color:#F8F8F8">1</span></span>
<span class="line"><span style="color:#B392F0">    d.Blocks[toIndex] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> fileID</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 changed things up significantly - instead of moving individual blocks, we needed to move
entire files at once, but only if there was enough continuous free space to the left. Files had to
be processed in decreasing order of file ID. This required new helper functions to find file sizes
and continuous free space:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> (d </span><span style="color:#F97583">*</span><span style="color:#B392F0">Disk) findFileSize(pos </span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> pos </span><span style="color:#F97583">&lt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#F97583"> ||</span><span style="color:#B392F0"> pos </span><span style="color:#F97583">&gt;=</span><span style="color:#B392F0"> len(d.Blocks) </span><span style="color:#F97583">||</span><span style="color:#B392F0"> d.Blocks[pos] </span><span style="color:#F97583">==</span><span style="color:#F97583"> -</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    fileID </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> d.Blocks[pos]</span></span>
<span class="line"><span style="color:#B392F0">    start </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> pos</span></span>
<span class="line"><span style="color:#6B737C">    // Find start of file</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> start </span><span style="color:#F97583">&gt;=</span><span style="color:#F8F8F8"> 0</span><span style="color:#F97583"> &amp;&amp;</span><span style="color:#B392F0"> d.Blocks[start] </span><span style="color:#F97583">==</span><span style="color:#B392F0"> fileID {</span></span>
<span class="line"><span style="color:#B392F0">        start</span><span style="color:#F97583">--</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">    start</span><span style="color:#F97583">++</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    end </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> pos</span></span>
<span class="line"><span style="color:#6B737C">    // Find end of file</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> end </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(d.Blocks) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> d.Blocks[end] </span><span style="color:#F97583">==</span><span style="color:#B392F0"> fileID {</span></span>
<span class="line"><span style="color:#B392F0">        end</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> end </span><span style="color:#F97583">-</span><span style="color:#B392F0"> start</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> (d </span><span style="color:#F97583">*</span><span style="color:#B392F0">Disk) findFreeSpaceSize(pos </span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    size </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> pos; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(d.Blocks) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> d.Blocks[i] </span><span style="color:#F97583">==</span><span style="color:#F97583"> -</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">; i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        size</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> size</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>One of the trickiest parts was managing the movement of whole files while ensuring we didn’t
overwrite other files in the process:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> (d </span><span style="color:#F97583">*</span><span style="color:#B392F0">Disk) moveWholeFile(fromIndex, toIndex, size </span><span style="color:#F97583">int</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#B392F0">    fileID </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> d.Blocks[fromIndex]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // Clear old location</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> size; i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        d.Blocks[fromIndex</span><span style="color:#F97583">+</span><span style="color:#B392F0">i] </span><span style="color:#F97583">=</span><span style="color:#F97583"> -</span><span style="color:#F8F8F8">1</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // Place at new location</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> size; i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        d.Blocks[toIndex</span><span style="color:#F97583">+</span><span style="color:#B392F0">i] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> fileID</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-16">Thoughts</h3>
<p>This puzzle was quite challenging, primarily because it required careful state management and
precise implementation of different movement strategies for each part. The main challenges were:</p>
<ol>
<li>Understanding the dense disk map format and correctly translating it into a workable
representation</li>
<li>Implementing the block-by-block movement logic for Part 1 while maintaining file integrity</li>
<li>Making the mental shift to whole-file movements in Part 2</li>
<li>Managing edge cases like ensuring continuous free space and processing files in the correct order</li>
</ol>
<p>The biggest trap was assuming Part 2 would be more complex than Part 1 - while it required different
logic, moving whole files at once was actually simpler in some ways than the careful block-by-block
movements of Part 1. The key insight was realizing that Part 2’s constraints actually made the
problem more deterministic, since files could only move if there was enough continuous free space to
their left.</p>
<p>I’d rate this an 7/10 difficulty. While the concepts weren’t extremely complex, getting all the
details right and handling both parts correctly required careful thought and implementation. The
transition from Part 1 to Part 2 was particularly interesting, requiring a complete rethink of the
movement strategy while still maintaining the core disk state management.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-8-resonant-collinearity">Day 8: Resonant Collinearity</h2>
<p>Today’s puzzle was about antenna signals and finding special points called antinodes in a 2D grid.
Each antenna has a specific frequency (represented by a letter or digit), and antinodes form when
specific geometric conditions are met between antennas of the same frequency.</p>
<p>For Part 1, antinodes occur at any point that’s collinear (in a straight line) with two antennas of
the same frequency, but only when that point is twice as far from one antenna as it is from the
other. I approached this by first parsing the grid and grouping antennas by frequency:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Grid [][]</span><span style="color:#F97583">rune</span></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Position </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    x, y </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> getFrequencies(grid Grid) </span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">rune</span><span style="color:#B392F0">][]Position {</span></span>
<span class="line"><span style="color:#B392F0">    frequencies </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">rune</span><span style="color:#B392F0">][]Position)</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> y </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; y </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(grid); y</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> x </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; x </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(grid[y]); x</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            char </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> grid[y][x]</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> char </span><span style="color:#F97583">!=</span><span style="color:#FFAB70"> &#39;.&#39;</span><span style="color:#B392F0"> { </span><span style="color:#6B737C">// ignores filler spaces</span></span>
<span class="line"><span style="color:#B392F0">                frequencies[char] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(frequencies[char], Position{x, y})</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> frequencies</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core logic for finding antinodes involves checking if points are collinear and satisfy the
distance ratio requirement. To avoid floating-point precision issues, I used squared distances:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> isAntinode(p, a, b Position) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#F97583"> !</span><span style="color:#B392F0">isCollinear(p, a, b) {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // Calculate squared distances</span></span>
<span class="line"><span style="color:#B392F0">    dap </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> distanceSquared(a, p)</span></span>
<span class="line"><span style="color:#B392F0">    dbp </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> distanceSquared(b, p)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // Check if either distance is twice the other</span></span>
<span class="line"><span style="color:#6B737C">    // Note: We compare squares, so it&#39;s 4 times instead of 2 times</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> dap </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 4</span><span style="color:#F97583">*</span><span style="color:#B392F0">dbp </span><span style="color:#F97583">||</span><span style="color:#B392F0"> dbp </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 4</span><span style="color:#F97583">*</span><span style="color:#B392F0">dap</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 introduced “resonant harmonics” which simplified the rules - an antinode now occurs at any
point that’s collinear with two antennas of the same frequency, regardless of distance. This
actually made the calculation simpler, but required checking every grid position:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">if</span><span style="color:#B392F0"> harmonic {</span></span>
<span class="line"><span style="color:#6B737C">    // Part 2: Check every point in the grid for collinearity</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> y </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; y </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(grid); y</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> x </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; x </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(grid[y]); x</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            p </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> Position{x, y}</span></span>
<span class="line"><span style="color:#6B737C">            // Check if this point is collinear with any pair of antennas</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(pos); i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">                for</span><span style="color:#B392F0"> j </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> i </span><span style="color:#F97583">+</span><span style="color:#F8F8F8"> 1</span><span style="color:#B392F0">; j </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(pos); j</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">                    if</span><span style="color:#B392F0"> isCollinear(p, pos[i], pos[j]) {</span></span>
<span class="line"><span style="color:#B392F0">                        antinodes[p] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#F97583">                        break</span></span>
<span class="line"><span style="color:#B392F0">                    }</span></span>
<span class="line"><span style="color:#B392F0">                }</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-17">Thoughts</h3>
<p>Today’s puzzle was an interesting mix of geometry and efficient grid searching. The main challenges
were:</p>
<ol>
<li>Getting the collinearity check right without running into floating-point precision issues</li>
<li>Efficiently calculating distances and ratios for Part 1</li>
<li>Managing the transition between the complex distance rules in Part 1 and the simpler but more
computationally intensive Part 2</li>
<li>Keeping track of unique antinode positions when multiple antenna pairs might create antinodes at
the same point</li>
</ol>
<p>A key insight was using cross multiplication in the collinearity check to avoid division:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> isCollinear(p, a, b Position) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    dx1 </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> a.x </span><span style="color:#F97583">-</span><span style="color:#B392F0"> p.x</span></span>
<span class="line"><span style="color:#B392F0">    dy1 </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> a.y </span><span style="color:#F97583">-</span><span style="color:#B392F0"> p.y</span></span>
<span class="line"><span style="color:#B392F0">    dx2 </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> b.x </span><span style="color:#F97583">-</span><span style="color:#B392F0"> p.x</span></span>
<span class="line"><span style="color:#B392F0">    dy2 </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> b.y </span><span style="color:#F97583">-</span><span style="color:#B392F0"> p.y</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> dx1</span><span style="color:#F97583">*</span><span style="color:#B392F0">dy2 </span><span style="color:#F97583">==</span><span style="color:#B392F0"> dx2</span><span style="color:#F97583">*</span><span style="color:#B392F0">dy1</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>I’d rate this a 6/10 difficulty - while the geometric concepts weren’t too complex, implementing
them correctly and efficiently required careful thinking and good problem-solving skills. Part 2’s
twist was clever, forcing us to rethink our approach even though it technically simplified the
problem.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-7-bridge-repair">Day 7: Bridge Repair</h2>
<p>Today’s puzzle was about evaluating arithmetic expressions with a twist. We needed to determine if
sequences of numbers could be combined using operators to produce specific target values. The catch?
Operators are evaluated strictly left-to-right (no precedence rules), and the numbers must be used
in their given order.</p>
<p>For Part 1, we had to work with addition (+) and multiplication (*) operators. Each line in the
input contained a target value followed by a sequence of numbers. For example:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span></span></span>
<span class="line"><span>190: 10 19 3267: 81 40 27 292: 11 6 16 20</span></span>
<span class="line"><span></span></span></code></pre>
<p>I approached this using backtracking to try all possible operator combinations. First, I created a
map to store the parsed input:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> parseInput(input </span><span style="color:#F97583">string</span><span style="color:#B392F0">) </span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">][]</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    calibrations </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">][]</span><span style="color:#F97583">int</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> _, line </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> strings.Split(input, </span><span style="color:#FFAB70">&quot;\n&quot;</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#B392F0">        parts </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strings.Split(line, </span><span style="color:#FFAB70">&quot;: &quot;</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        key, _ </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strconv.Atoi(parts[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> _, val </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> strings.Split(parts[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">], </span><span style="color:#FFAB70">&quot; &quot;</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#B392F0">            val, _ </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strconv.Atoi(val)</span></span>
<span class="line"><span style="color:#B392F0">            calibrations[key] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(calibrations[key], val)</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> calibrations</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The core validation logic uses backtracking to try each possible operator at each position:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#B392F0"> backtrack </span><span style="color:#F97583">func</span><span style="color:#B392F0">(pos, curr </span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">bool</span></span>
<span class="line"><span style="color:#B392F0">backtrack </span><span style="color:#F97583">=</span><span style="color:#F97583"> func</span><span style="color:#B392F0">(pos, curr </span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">    // if we&#39;ve used all the numbers, check if we hit the target</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> pos </span><span style="color:#F97583">==</span><span style="color:#B392F0"> len(vals) {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#B392F0"> curr </span><span style="color:#F97583">==</span><span style="color:#B392F0"> target</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // try addition</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> backtrack(pos</span><span style="color:#F97583">+</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, curr</span><span style="color:#F97583">+</span><span style="color:#B392F0">vals[pos]) {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // try multiplication</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> backtrack(pos</span><span style="color:#F97583">+</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, curr</span><span style="color:#F97583">*</span><span style="color:#B392F0">vals[pos]) {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 introduced a new operator: concatenation (||). This operator joins the digits of two numbers
together (e.g., 12 || 345 = 12345). This required adding string manipulation to our solution:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">if</span><span style="color:#B392F0"> tryConcat {</span></span>
<span class="line"><span style="color:#6B737C">    // convert the current to a string, concat the next, convert back</span></span>
<span class="line"><span style="color:#B392F0">    currStr </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strconv.Itoa(curr)</span></span>
<span class="line"><span style="color:#B392F0">    nextStr </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strconv.Itoa(vals[pos])</span></span>
<span class="line"><span style="color:#B392F0">    concatNum, _ </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strconv.Atoi(currStr </span><span style="color:#F97583">+</span><span style="color:#B392F0"> nextStr)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> backtrack(pos</span><span style="color:#F97583">+</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, concatNum) {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>The main function just calls the <code>parseInput</code> function then loops over each calibration and calls
<code>backtrack</code> with the target value:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#B392F0">calibrations </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> parseInput(input)</span></span>
<span class="line"><span style="color:#B392F0">validKeys </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> key, vals </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> calibrations {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> isCalibrationValid(key, vals, part </span><span style="color:#F97583">==</span><span style="color:#F8F8F8"> 2</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#B392F0">        validKeys </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(validKeys, key)</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">return</span><span style="color:#B392F0"> utils.Sum(validKeys)</span></span></code></pre>
<h3 id="thoughts-18">Thoughts</h3>
<p>Today’s puzzle was a nice mix of arithmetic and string manipulation. The main challenge was handling
the left-to-right evaluation requirement and implementing the backtracking solution efficiently. The
addition of the concatenation operator in Part 2 added an interesting twist, requiring careful
string manipulation and handling of larger numbers.</p>
<p>The key insight was recognizing this as a backtracking problem where we try different operators at
each position. While we could potentially optimize further with caching or pruning, the current
solution provides a good balance between clarity and performance.</p>
<p>I’d rate this a 2/10 difficulty - not overly complex, but requires some careful implementation. I
saw some other people were having issues with their sum being higher than what a 32-bit integer can
hold, luckily I didn’t have that issue, idk why lol.</p>
<p><em>See you tomorrow!</em></p>
<h2 id="day-6-guard-gallivant">Day 6: Guard Gallivant</h2>
<p>Today’s puzzle involved simulating a guard’s patrol path in a grid-based map and predicting their
movements. The input consists of a grid where <code>^</code> represents the guard’s starting position (facing
up) and <code>#</code> represents obstacles.</p>
<p>For Part 1, we needed to calculate how many distinct positions the guard would visit before leaving
the mapped area. The guard follows a simple protocol:</p>
<ul>
<li>If there’s an obstacle in front, turn right 90 degrees</li>
<li>Otherwise, move forward one step</li>
</ul>
<p>My solution uses a Point and Direction system to track the guard’s movement through the grid:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Point </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    x, y </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Direction </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    dx, dy </span><span style="color:#F97583">int</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> Guard </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    pos Point</span></span>
<span class="line"><span style="color:#B392F0">    dir Direction</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Then we simulate the guard’s movement using a map to track visited positions and implement the
protocol:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> simulateGuardPath(grid [][]</span><span style="color:#F97583">byte</span><span style="color:#B392F0">, guard Guard, checkLoop </span><span style="color:#F97583">bool</span><span style="color:#B392F0">) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    visited </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[Point]</span><span style="color:#F97583">bool</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    visited[guard.pos] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        next </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> Point{</span></span>
<span class="line"><span style="color:#B392F0">            x: guard.pos.x </span><span style="color:#F97583">+</span><span style="color:#B392F0"> guard.dir.dx,</span></span>
<span class="line"><span style="color:#B392F0">            y: guard.pos.y </span><span style="color:#F97583">+</span><span style="color:#B392F0"> guard.dir.dy,</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#F97583"> !</span><span style="color:#B392F0">isInBounds(next, grid) {</span></span>
<span class="line"><span style="color:#F97583">            break</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> grid[next.y][next.x] </span><span style="color:#F97583">==</span><span style="color:#FFAB70"> &#39;#&#39;</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">            guard.turnRight()</span></span>
<span class="line"><span style="color:#F97583">            continue</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">        guard.pos </span><span style="color:#F97583">=</span><span style="color:#B392F0"> next</span></span>
<span class="line"><span style="color:#B392F0">        visited[guard.pos] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> len(visited)</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 flipped the problem around - we needed to find positions where placing a new obstacle would
cause the guard to get stuck in a loop. This required modifying our simulation to detect repeated
states (position + direction combinations):</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> State </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    pos Point</span></span>
<span class="line"><span style="color:#B392F0">    dir Direction</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> simLoop(grid [][]</span><span style="color:#F97583">byte</span><span style="color:#B392F0">, guard Guard) </span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    start </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> guard.pos</span></span>
<span class="line"><span style="color:#B392F0">    count </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> y </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> grid {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#B392F0"> x </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> grid[y] {</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> grid[y][x] </span><span style="color:#F97583">!=</span><span style="color:#FFAB70"> &#39;.&#39;</span><span style="color:#F97583"> ||</span><span style="color:#B392F0"> (Point{x, y} </span><span style="color:#F97583">==</span><span style="color:#B392F0"> start) {</span></span>
<span class="line"><span style="color:#F97583">                continue</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">            // create a copy of the grid with the new obstruction</span></span>
<span class="line"><span style="color:#B392F0">            newGrid </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([][]</span><span style="color:#F97583">byte</span><span style="color:#B392F0">, len(grid))</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> grid {</span></span>
<span class="line"><span style="color:#B392F0">                newGrid[i] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">byte</span><span style="color:#B392F0">, len(grid[i]))</span></span>
<span class="line"><span style="color:#B392F0">                copy(newGrid[i], grid[i])</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">            newGrid[y][x] </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> &#39;#&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#B392F0"> simulateGuardPath(newGrid, guard, </span><span style="color:#79B8FF">true</span><span style="color:#B392F0">) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">                count</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> count</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-19">Thoughts</h3>
<p>Today’s puzzle was a deceptively complex challenge in path simulation and state management. While
the initial rules seemed straightforward, implementing them correctly and especially handling Part 2
required significant problem-solving and careful debugging.</p>
<p>The trickiest aspects included:</p>
<ol>
<li>Getting the turn mechanics exactly right - the subtle interplay between direction changes and
movement needed precise implementation</li>
<li>Understanding that Part 2 wasn’t just about finding places to put obstacles, but about finding
positions that would create perfect loops</li>
<li>Realizing that detecting loops required tracking the complete state (position AND direction)
because the same position could be visited multiple times in different directions as part of a
valid patrol route</li>
<li>Managing the complexity of copying grids and running simulations for every possible obstacle
position in Part 2 without missing edge cases</li>
</ol>
<p>A key insight that took some time to reach was that the loop detection needed to look at the full
state of the guard - just tracking visited positions wasn’t enough. This realization led to
implementing the State struct to capture both position and direction:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">type</span><span style="color:#B392F0"> State </span><span style="color:#F97583">struct</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    pos Point</span></span>
<span class="line"><span style="color:#B392F0">    dir Direction</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Performance-wise, Part 2 involves simulating the guard’s path for every possible obstacle position,
which means we’re doing a lot of grid copying and path simulation. While there might be cleverer
ways to optimize this by analyzing patterns in the guard’s movement, sometimes the straightforward
approach, even if computationally intensive, is the most reliable path to a solution.</p>
<p>I’d rate this a 6/10 difficulty - while the core concepts aren’t overly complex, getting all the
pieces working together correctly required solid problem-solving skills and careful debugging. The
leap from Part 1 to Part 2 was particularly challenging, requiring a fundamental shift in how we
thought about the problem and tracked the guard’s state</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-5-print-queue">Day 5: Print Queue</h2>
<p>Today’s puzzle involved managing a print queue for safety manual updates using topological sorting.
The input consisted of rules about page ordering (in the form X|Y meaning page X must be printed
before page Y) and sequences of pages that needed to be printed.</p>
<p>Part 1 required checking if given sequences of pages satisfied all the applicable ordering rules.
For example, if we had rules like <code>47|53</code> and <code>75|29</code>, we needed to verify that page 47 came before
53 and page 75 came before 29 in each sequence. My solution uses a directed graph to represent these
dependencies:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> buildGraph(rules []Rule) Graph {</span></span>
<span class="line"><span style="color:#B392F0">    graph </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(Graph)</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> _, rule </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> rules {</span></span>
<span class="line"><span style="color:#B392F0">        graph[rule.before] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(graph[rule.before], rule.after)</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> graph</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Then for each squence, I check if it satisfies all applicable rules by tracking page positions and
verifying dependencies:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> isValidSequence(seq []</span><span style="color:#F97583">int</span><span style="color:#B392F0">, graph Graph) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    positions </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i, page </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> seq {</span></span>
<span class="line"><span style="color:#B392F0">        positions[page] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> i</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(seq); i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        page </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> seq[i]</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> after, exists </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> graph[page]; exists {</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#B392F0"> _, mustBeAfter </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> after {</span></span>
<span class="line"><span style="color:#F97583">                if</span><span style="color:#B392F0"> pos, exists </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> positions[mustBeAfter]; exists {</span></span>
<span class="line"><span style="color:#F97583">                    if</span><span style="color:#B392F0"> pos </span><span style="color:#F97583">&lt;=</span><span style="color:#B392F0"> i {</span></span>
<span class="line"><span style="color:#F97583">                        return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">                    }</span></span>
<span class="line"><span style="color:#B392F0">                }</span></span>
<span class="line"><span style="color:#B392F0">            }</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 flipped the problem around - instead of just validating sequences, we needed to correctly
order the invalid sequences using Kahn’s topological sorting algorithm. This required tracking
in-degrees for each node and carefully managing the order of processing to match the expected
output:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> topologicalSort(pages []</span><span style="color:#F97583">int</span><span style="color:#B392F0">, fullGraph Graph) []</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">    // Create subgraph with only relevant pages...</span></span>
<span class="line"><span style="color:#B392F0">    nodes </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">*</span><span style="color:#B392F0">Node)</span></span>
<span class="line"><span style="color:#6B737C">    // Build dependencies...</span></span>
<span class="line"><span style="color:#6B737C">    // Process queue in correct order...</span></span>
<span class="line"><span style="color:#6B737C">    // Return sorted sequence...</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Topological sort is a long algorithm in Go, so I didn’t write it all here, but the full solution is
available on my <a href="https://github.com/dickeyy/adventofcode/blob/main/2024/day-5/main.go">GitHub</a>.</p>
<h3 id="thoughts-20">Thoughts</h3>
<p>Today’s puzzle was a nice application of graph theory and topological sorting. While the core
concept wasn’t too complex, getting all the edge cases right and ensuring the correct ordering in
Part 2 required careful implementation.</p>
<p>The trickiest part was handling Part 2’s requirement to generate valid orderings. Making sure the
topological sort produced the correct ordering when multiple valid orderings were possible took some
debugging to get right. The key insight was realizing we needed to carefully manage the queue order
to ensure deterministic output.</p>
<p>The problem was also a good reminder of how important it is to properly model the problem space -
representing the dependencies as a directed graph made both parts much more straightforward to
solve.</p>
<p>I’d rate this a 5/10 difficulty - not overly complex conceptually, but requiring solid understanding
of graph algorithms and attention to detail in the implementation.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-4-ceres-search">Day 4: Ceres Search</h2>
<p>Today’s puzzle was an interesting twist on the classic word search problem. Instead of searching for
a single instance of “XMAS”, we needed to find all possible occurrences in Part 1, and then pivot to
finding X-shaped “MAS” patterns in Part 2.</p>
<p>There’s quite a bit of code for today, so I’m not going to include it all here. As always, the full
solution is available on my
<a href="https://github.com/dickeyy/adventofcode/blob/main/2024/day-4/main.go">GitHub</a>.</p>
<p>For Part 1, I implemented a grid search that looks for “XMAS” in all eight possible directions
(horizontal, vertical, and diagonal) from any starting position. The approach uses direction vectors
to check each possible orientation:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#B392F0"> dirs </span><span style="color:#F97583">=</span><span style="color:#B392F0"> []Direction{</span></span>
<span class="line"><span style="color:#B392F0">    {</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},   </span><span style="color:#6B737C">// right</span></span>
<span class="line"><span style="color:#B392F0">    {</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">, </span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},  </span><span style="color:#6B737C">// left</span></span>
<span class="line"><span style="color:#B392F0">    {</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">},   </span><span style="color:#6B737C">// down</span></span>
<span class="line"><span style="color:#B392F0">    {</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">},  </span><span style="color:#6B737C">// up</span></span>
<span class="line"><span style="color:#B392F0">    {</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},   </span><span style="color:#6B737C">// down-right</span></span>
<span class="line"><span style="color:#B392F0">    {</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},  </span><span style="color:#6B737C">// down-left</span></span>
<span class="line"><span style="color:#B392F0">    {</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">},  </span><span style="color:#6B737C">// up-right</span></span>
<span class="line"><span style="color:#B392F0">    {</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">, </span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">}, </span><span style="color:#6B737C">// up-left</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Part 2 required a different approach since we needed to find X-shaped patterns where each diagonal
spells either “MAS” or “SAM”. I optimized this by only checking positions that contain ‘A’ (the
center of the X) and then validating the diagonals:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">if</span><span style="color:#B392F0"> grid[row][col] </span><span style="color:#F97583">==</span><span style="color:#FFAB70"> &#39;A&#39;</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> checkXMASCross(grid, row, col, rows, cols) {</span></span>
<span class="line"><span style="color:#B392F0">        count</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<h3 id="thoughts-21">Thoughts</h3>
<p>Today’s puzzle was quite the step up from the last one (in my opinion). While grid traversal and
pattern matchiing might sound straightforward, implementing both parts correctly required careful
thought and precise implementation.</p>
<p>The part that really made thhis puzzle tricky was handling all the edge cases correcly. In part 1,
ensuring the pattern checking worked in all eight directions while staying within bounds took some
debugging to get right. The pattern validation logic needed to be both efficient and thorough since
we were looking for all possible instances of “XMAS”.</p>
<p>Part 2’s X-pattern search was even more devious - it fundamentally changed how we needed to think
about the problem. The realization that we could optimize by starting from ‘A’ positions helped, but
validating the diagonal patterns correctly and handling the fact that “MAS” could be reversed added
extra complexity. Plus, the way the puzzle description led us to initially think about it in terms
of overlapping “MAS” strings, when really it was about finding X-shaped patterns, was quite clever.</p>
<p>Performance-wise, while both parts run quickly thanks to the optimized starting positions (X/A),
getting there required several refactoring attempts to handle all cases correctly while maintaining
efficiency.</p>
<p>I’d rate this a 5/10 difficulty - definitely more challenging than the first three days and
requiring some solid problem-solving skills to implement correctly. The misdirection in Part 2 and
the need for precise pattern matching logic made this a satisfyingly complex puzzle.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-3-mull-it-over">Day 3: Mull it Over</h2>
<p>Today’s puzzle was about parsing corrupted computer memory and extracting valid multiplication
instructions. The input consists of strings containing <code>mul(x,y)</code> patterns mixed with various
invalid characters and conditionals. Essentially it’s a whole bunch of regex.</p>
<p>For part 1, you must find the number of valid <code>mul</code> instructions (where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span> are 1-3 digit
integers) and sum up their products. For example:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>xmul(2,4)mul[3,7]a2mul(4,3)</span></span></code></pre>
<p>Would be <code>(2*4) + (4*3) = 20</code>.</p>
<p>Only the properly formatted <code>mul(x,y)</code> patterns count. My solution uses regex to extract these
patters:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> getMulNums(input </span><span style="color:#F97583">string</span><span style="color:#B392F0">) [][]</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    muls </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([][]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    re </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> regexp.MustCompile(</span><span style="color:#FFAB70">`mul\((\d+),(\d+)\)`</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">    matches </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> re.FindAllStringSubmatchIndex(input, </span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // go on to process each match ...</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>You then just need to sum up the products of each pair.</p>
<p>Part 2 introduces conditional logic with <code>do()</code> and <code>don&#39;t()</code> instructions that enable or disable
multiplication operations. I modified the regex pattern to capture these new instructions and added
a boolean flag to track whether multiplications should be processed.</p>
<p>For this part, I just modified the regex pattern to capture these new instructions, added a
conditional boolean to the <code>getMulNums</code> function, and then added an <code>allowMul</code> boolean which (if the
conditional is true) would process the <code>do()</code> and <code>dont()</code> instructions.</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> getMulNums(input </span><span style="color:#F97583">string</span><span style="color:#B392F0">, conditional </span><span style="color:#F97583">bool</span><span style="color:#B392F0">) [][]</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">    // ...</span></span>
<span class="line"><span style="color:#B392F0">    re </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> regexp.MustCompile(</span><span style="color:#FFAB70">`mul\(\d+,\d+\)|do\(\)|don&#39;t\(\)`</span><span style="color:#B392F0">) </span><span style="color:#6B737C">// new regex</span></span>
<span class="line"><span style="color:#6B737C">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    allowMul </span><span style="color:#F97583">:=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	for</span><span style="color:#B392F0"> _, match </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> matches {</span></span>
<span class="line"><span style="color:#B392F0">		op </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> input[match[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]:match[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // this part only happens if we are doing part 2</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#B392F0"> conditional {</span></span>
<span class="line"><span style="color:#F97583">			if</span><span style="color:#B392F0"> op </span><span style="color:#F97583">==</span><span style="color:#FFAB70"> &quot;do()&quot;</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">				allowMul </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">			} </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#B392F0"> op </span><span style="color:#F97583">==</span><span style="color:#FFAB70"> &quot;don&#39;t()&quot;</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">				allowMul </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">			}</span></span>
<span class="line"><span style="color:#B392F0">		}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // slightly modified from before due to the new conditional</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#B392F0"> allowMul </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> strings.HasPrefix(op, </span><span style="color:#FFAB70">&quot;mul&quot;</span><span style="color:#B392F0">) {</span></span>
<span class="line"><span style="color:#B392F0">			muls </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(muls, extractNumsFromMul(op))</span></span>
<span class="line"><span style="color:#B392F0">		}</span></span>
<span class="line"><span style="color:#B392F0">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#B392F0"> muls</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Aside from these updates, I also made a <code>extractNumsFromMul</code> function to make my code a bit easier
to read:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> extractNumsFromMul(op </span><span style="color:#F97583">string</span><span style="color:#B392F0">) []</span><span style="color:#F97583">int</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">	numRe </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> regexp.MustCompile(</span><span style="color:#FFAB70">`(\d+)`</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">	nums </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> numRe.FindAllStringSubmatch(op, </span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">	x, _ </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strconv.Atoi(nums[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">][</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">])</span></span>
<span class="line"><span style="color:#B392F0">	y, _ </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> strconv.Atoi(nums[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">][</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">])</span></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#B392F0"> []</span><span style="color:#F97583">int</span><span style="color:#B392F0">{x, y}</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>As always, the full solution is available on my
<a href="https://github.com/dickeyy/adventofcode/blob/main/2024/day-3/main.go">GitHub</a>.</p>
<h3 id="thoughts-22">Thoughts</h3>
<p>Today was an interesting exercise in string parsing and regex. While the core logic wasn’t too
complex, getting the regex patterns right and handling the conditional state properly required some
careful thinking.</p>
<p>The biggest challenge was probably crafting the regex pattern to capture both the multiplication
instructions and the conditional statements while ignoring all the noise characters.</p>
<p>I’d rate this a 2/10 difficulty - not particularly difficult, just some clever regex.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-2-red-nosed-reports">Day 2: Red-Nosed Reports</h2>
<p>Not too bad today to be honest. I got both parts done in &lt; 45 minutes after I started, which
included an algorithm rewrite is not too bad for me.</p>
<p>Today’s problem was about processing a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^{m\times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> matrix of integers. Each row is a
list of “levels”. For each row, you need to verify it passes a few rules:</p>
<ol>
<li>The row can only increase OR decrease, no switching part way through.</li>
<li>The difference between two consecutive levels must be between 1 and 3 (inclusive).</li>
</ol>
<p>For part 1, you need to sum up the number of passing rows (rows that pass the above rules). For
example,</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>7 6 4 2 1</span></span>
<span class="line"><span>1 2 7 8 9</span></span>
<span class="line"><span>9 7 6 2 1</span></span>
<span class="line"><span>1 3 2 4 5</span></span>
<span class="line"><span>8 6 4 4 1</span></span>
<span class="line"><span>1 3 6 7 9</span></span></code></pre>
<p>Has 2 safe rows (rows 1 and 6). Part 1 is pretty simple, once you have a working algorithm. Mine
looks like this:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> isValidRow(row []</span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> len(row) </span><span style="color:#F97583">&lt;</span><span style="color:#F8F8F8"> 2</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // determine the initial direction from the first 2 nums</span></span>
<span class="line"><span style="color:#B392F0">    isInc </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> row[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">] </span><span style="color:#F97583">&gt;</span><span style="color:#B392F0"> row[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // check first pair meets difference criteria</span></span>
<span class="line"><span style="color:#B392F0">    initialDiff </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> utils.Abs(row[</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">] </span><span style="color:#F97583">-</span><span style="color:#B392F0"> row[</span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">])</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> initialDiff </span><span style="color:#F97583">&lt;</span><span style="color:#F8F8F8"> 1</span><span style="color:#F97583"> ||</span><span style="color:#B392F0"> initialDiff </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 3</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">    // check remaining pairs</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 1</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(row)</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">; i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">        curr, next </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> row[i], row[i</span><span style="color:#F97583">+</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">]</span></span>
<span class="line"><span style="color:#B392F0">        diff </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> next </span><span style="color:#F97583">-</span><span style="color:#B392F0"> curr</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // if direction changes, sequence is invalid</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> (diff </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">) </span><span style="color:#F97583">!=</span><span style="color:#B392F0"> isInc {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">        // check the diff is within bounds</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> utils.Abs(diff) </span><span style="color:#F97583">&lt;</span><span style="color:#F8F8F8"> 1</span><span style="color:#F97583"> ||</span><span style="color:#B392F0"> utils.Abs(diff) </span><span style="color:#F97583">&gt;</span><span style="color:#F8F8F8"> 3</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p><em>Note: <code>utils.Abs</code> is a helper function that can take in <code>int</code> rather than the <code>math.Abs</code> function
which takes in <code>float64</code>.</em></p>
<p>Go through each row in the matrix, if it is valid, increment the counter. Easy peasy.</p>
<p>For part 2, if a row is invalid, you need to now check if you can make it valid by removing any 1
level from the row. For example, the above matrix now has 4 safe rows (rows 1, 4, 5, and 6). I had
trouble figuring out how to do this efficiently, so it took some time, but I eventually came up with
this:</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#F97583">func</span><span style="color:#B392F0"> canBecomeValid(row []</span><span style="color:#F97583">int</span><span style="color:#B392F0">) </span><span style="color:#F97583">bool</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#6B737C">    // try removing each num and check if the resulting row is valid</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> row {</span></span>
<span class="line"><span style="color:#6B737C">        // create a new slice without the current num</span></span>
<span class="line"><span style="color:#B392F0">        newRow </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">, len(row)</span><span style="color:#F97583">-</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        newRow </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(newRow, row[:i]</span><span style="color:#F97583">...</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">        newRow </span><span style="color:#F97583">=</span><span style="color:#B392F0"> append(newRow, row[i</span><span style="color:#F97583">+</span><span style="color:#F8F8F8">1</span><span style="color:#B392F0">:]</span><span style="color:#F97583">...</span><span style="color:#B392F0">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#B392F0"> isValidRow(newRow) {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#B392F0">        }</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>This just checks if a given row can become valid by removing any 1 level from the row, it tests
every number and then returns true if it can. You then modify the main function a bit for part 2 to
check if either <code>isValidRow</code> or <code>canBecomeValid</code> returns true, if so, increment the counter. Done!</p>
<h3 id="thoughts-23">Thoughts</h3>
<p>Today was a pretty cool problem. It seems trivial at first but then there are a few things that
catch you off guard. Still, relatively easy though, it will get harder the further into the month we
go.</p>
<p>This algorithm would be much easier in Python using <code>zip</code> and even day 1 would be easier with this
same function. I may write a <code>Zip2</code> function in Go as a util in the future since it’s 2 days in a
row that my life would be so much easier. That said, this algorithm works and is still pretty fast.
Both parts ran in &lt; 600 µs on my server. The point of AoC (for me) is not to write the most
efficient algorithm possible and not to get on the leaderboard, but to learn and improve. From doing
AoC for the past few years, I’ve learned a lot about algorithms and data structures, and in my book,
that’s a win.</p>
<p>Overall, I’d give this a 3/10 difficulty, simply because it was a bit of work to find a
semi-efficient solution for part 2.</p>
<p><em>See you tomorrow!</em></p>
<hr/>
<h2 id="day-1-historian-hysteria">Day 1: Historian Hysteria</h2>
<p>First day of AoC 2024! This year I decided to do all my solutions in <a href="https://golang.org/">Go</a>.</p>
<p>Today’s problem was pretty easy. You’re given a list of integers, 2 in each row (separated by 3
spaces).</p>
<p>For part 1, you need to pair the smallest number on the left with the smallest on the right, then
the second smallest, then the third, and so on. For example,</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>1   4</span></span>
<span class="line"><span>3   1</span></span>
<span class="line"><span>4   3</span></span>
<span class="line"><span>8   2</span></span></code></pre>
<p>Would be paired as <code>(1, 1), (3, 2), (4, 3), (8, 4)</code>. Then, you need to sum up the differences
between each pair. With the above example, the sum would be <code>0 + 1 + 1 + 4 = 6</code>.</p>
<p>My approach for part 1 was to first separate the numbers into two lists <code>left</code> and <code>right</code>, sort
them, and iterate over the left list calculating the absolute difference between each pair. Since we
know the right list is the same length as the left, we can just iterate over one and associate the
index with the other.</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#B392F0">left </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#B392F0">right </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make([]</span><span style="color:#F97583">int</span><span style="color:#B392F0">, </span><span style="color:#F8F8F8">0</span><span style="color:#B392F0">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6B737C">// parse input ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">sort.Ints(left)</span></span>
<span class="line"><span style="color:#B392F0">sort.Ints(right)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> i </span><span style="color:#F97583">:=</span><span style="color:#F8F8F8"> 0</span><span style="color:#B392F0">; i </span><span style="color:#F97583">&lt;</span><span style="color:#B392F0"> len(left); i</span><span style="color:#F97583">++</span><span style="color:#B392F0"> {</span></span>
<span class="line"><span style="color:#B392F0">    out </span><span style="color:#F97583">+=</span><span style="color:#F97583"> int</span><span style="color:#B392F0">(math.Abs(</span><span style="color:#F97583">float64</span><span style="color:#B392F0">(left[i] </span><span style="color:#F97583">-</span><span style="color:#B392F0"> right[i])))</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>Pretty easy!</p>
<p>For part 2, you need to multiply each number in the left list by the number of times it appears in
the right list and sum up the results. For the above example, the result would be
<code>(1 * 1) + (3 * 1) + (4 * 1) + (8 * 1) = 16</code>.</p>
<p>My approach in part 2 was to make a hashmap of the right list associating each number with its
frequency, then iterate over the left list and multiply each number by its frequency in the hashmap.</p>
<pre class="astro-code min-dark" style="background-color:#1f1f1f;color:#b392f0;overflow-x:auto" tabindex="0" data-language="go"><code><span class="line"><span style="color:#B392F0">freq </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> make(</span><span style="color:#F97583">map</span><span style="color:#B392F0">[</span><span style="color:#F97583">int</span><span style="color:#B392F0">]</span><span style="color:#F97583">int</span><span style="color:#B392F0">)</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> _, num </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> right {</span></span>
<span class="line"><span style="color:#B392F0">    freq[num]</span><span style="color:#F97583">++</span></span>
<span class="line"><span style="color:#B392F0">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#B392F0"> _, num </span><span style="color:#F97583">:=</span><span style="color:#F97583"> range</span><span style="color:#B392F0"> left {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> f, exists </span><span style="color:#F97583">:=</span><span style="color:#B392F0"> freq[num]; exists {</span></span>
<span class="line"><span style="color:#B392F0">        out </span><span style="color:#F97583">+=</span><span style="color:#B392F0"> num </span><span style="color:#F97583">*</span><span style="color:#B392F0"> f</span></span>
<span class="line"><span style="color:#B392F0">    }</span></span>
<span class="line"><span style="color:#B392F0">}</span></span></code></pre>
<p>For this part, you could use a nested for loop, but I wanted it to be a bit faster. The nested for
loop is O(n^2), whereas the hashmap is O(n).</p>
<h3 id="thoughts-24">Thoughts</h3>
<p>Super easy today. Looking back on last year’s day 1 problem, this was a walk in the park. I had fun
optimizing my solution, and yes, I know it’s not the most efficient algorithm, but it’s easy to
understand and it works.</p>
<p>Overall, today was pretty easy, about a 1/10 difficulty.</p>
<p><em>See you tomorrow!</em></p> </article>  </div> </div> </main> <footer class="w-full px-4 py-4"> <div class="flex flex-row gap-4 items-start justify-between"> <div class="flex flex-row items-center justify-between gap-2 md:justify-start"> <p class="text-xs font-normal text-foreground/40">
&copy; <span class="font-serif italic">2025</span> Kyle Dickey
</p> </div> <div class="flex items-center justify-center gap-4"> <a href="https://github.com/dickeyy" target="_blank"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="size-3 fill-foreground/40 hover:fill-foreground/80 transition-colors ease-in-out"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg> </a> <a href="https://bsky.app/profile/kyle.so" target="_blank"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" class="size-3 fill-foreground/40 hover:fill-foreground/80 transition-colors ease-in-out"><path d="M407.8 294.7c-3.3-.4-6.7-.8-10-1.3c3.4 .4 6.7 .9 10 1.3zM288 227.1C261.9 176.4 190.9 81.9 124.9 35.3C61.6-9.4 37.5-1.7 21.6 5.5C3.3 13.8 0 41.9 0 58.4S9.1 194 15 213.9c19.5 65.7 89.1 87.9 153.2 80.7c3.3-.5 6.6-.9 10-1.4c-3.3 .5-6.6 1-10 1.4C74.3 308.6-9.1 342.8 100.3 464.5C220.6 589.1 265.1 437.8 288 361.1c22.9 76.7 49.2 222.5 185.6 103.4c102.4-103.4 28.1-156-65.8-169.9c-3.3-.4-6.7-.8-10-1.3c3.4 .4 6.7 .9 10 1.3c64.1 7.1 133.6-15.1 153.2-80.7C566.9 194 576 75 576 58.4s-3.3-44.7-21.6-52.9c-15.8-7.1-40-14.9-103.2 29.8C385.1 81.9 314.1 176.4 288 227.1z"></path></svg> </a> <a href="https://twitter.com/kyledickeyy" target="_blank"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="size-3 fill-foreground/40 hover:fill-foreground/80 transition-colors ease-in-out"><path d="M459.4 151.7c.3 4.5 .3 9.1 .3 13.6 0 138.7-105.6 298.6-298.6 298.6-59.5 0-114.7-17.2-161.1-47.1 8.4 1 16.6 1.3 25.3 1.3 49.1 0 94.2-16.6 130.3-44.8-46.1-1-84.8-31.2-98.1-72.8 6.5 1 13 1.6 19.8 1.6 9.4 0 18.8-1.3 27.6-3.6-48.1-9.7-84.1-52-84.1-103v-1.3c14 7.8 30.2 12.7 47.4 13.3-28.3-18.8-46.8-51-46.8-87.4 0-19.5 5.2-37.4 14.3-53 51.7 63.7 129.3 105.3 216.4 109.8-1.6-7.8-2.6-15.9-2.6-24 0-57.8 46.8-104.9 104.9-104.9 30.2 0 57.5 12.7 76.7 33.1 23.7-4.5 46.5-13.3 66.6-25.3-7.8 24.4-24.4 44.8-46.1 57.8 21.1-2.3 41.6-8.1 60.4-16.2-14.3 20.8-32.2 39.3-52.6 54.3z"></path></svg> </a> <a href="https://www.linkedin.com/in/kyletdickey/" target="_blank"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="size-3 fill-foreground/40 hover:fill-foreground/80 transition-colors ease-in-out"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg> </a> <a href="https://leetcode.com/dickey/" target="_blank"> <svg fill="#000000" width="800px" height="800px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" class="size-3 fill-foreground/40 hover:fill-foreground/80 transition-colors ease-in-out"><path d="M21.469 23.907l-3.595 3.473c-0.624 0.625-1.484 0.885-2.432 0.885s-1.807-0.26-2.432-0.885l-5.776-5.812c-0.62-0.625-0.937-1.537-0.937-2.485 0-0.952 0.317-1.812 0.937-2.432l5.76-5.844c0.62-0.619 1.5-0.859 2.448-0.859s1.808 0.26 2.432 0.885l3.595 3.473c0.687 0.688 1.823 0.663 2.536-0.052 0.708-0.713 0.735-1.848 0.047-2.536l-3.473-3.511c-0.901-0.891-2.032-1.505-3.261-1.787l3.287-3.333c0.688-0.687 0.667-1.823-0.047-2.536s-1.849-0.735-2.536-0.052l-13.469 13.469c-1.307 1.312-1.989 3.113-1.989 5.113 0 1.996 0.683 3.86 1.989 5.168l5.797 5.812c1.307 1.307 3.115 1.937 5.115 1.937 1.995 0 3.801-0.683 5.109-1.989l3.479-3.521c0.688-0.683 0.661-1.817-0.052-2.531s-1.849-0.74-2.531-0.052zM27.749 17.349h-13.531c-0.932 0-1.692 0.801-1.692 1.791 0 0.991 0.76 1.797 1.692 1.797h13.531c0.933 0 1.693-0.807 1.693-1.797 0-0.989-0.76-1.791-1.693-1.791z"></path></svg> </a> </div> </div> </footer> </body>
<!-- Mirrored from kyle.so/writing/aoc-2024 by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 04 Feb 2026 14:30:18 GMT -->
</html>